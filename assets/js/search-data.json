{
  
    
        "post0": {
            "title": "케라스를 사용한 인공 신경망 소개",
            "content": "!sudo apt-get install -y fonts-nanum !sudo fc-cache -fv !rm ~/.cache/matplotlib -rf . . Reading package lists... Done Building dependency tree Reading state information... Done fonts-nanum is already the newest version (20170925-1). 0 upgraded, 0 newly installed, 0 to remove and 37 not upgraded. /usr/share/fonts: caching, new cache contents: 0 fonts, 1 dirs /usr/share/fonts/truetype: caching, new cache contents: 0 fonts, 3 dirs /usr/share/fonts/truetype/humor-sans: caching, new cache contents: 1 fonts, 0 dirs /usr/share/fonts/truetype/liberation: caching, new cache contents: 16 fonts, 0 dirs /usr/share/fonts/truetype/nanum: caching, new cache contents: 10 fonts, 0 dirs /usr/local/share/fonts: caching, new cache contents: 0 fonts, 0 dirs /root/.local/share/fonts: skipping, no such directory /root/.fonts: skipping, no such directory /var/cache/fontconfig: cleaning cache directory /root/.cache/fontconfig: not cleaning non-existent cache directory /root/.fontconfig: not cleaning non-existent cache directory fc-cache: succeeded . import numpy as np import matplotlib.pyplot as plt import matplotlib.font_manager as fm import seaborn as sns . 10.1 &#49373;&#47932;&#54617;&#51201; &#45684;&#47088;&#50640;&#49436; &#51064;&#44277; &#45684;&#47088;&#44620;&#51648; . . 우선 왼쪽의 그림은 고등학교 생명과학1 시간에 배운 친숙한 뉴런의 모습이다. 교과서에는 가지돌기로 나왔던 것 같은데 수상돌기나 가지돌기나 같은 말로 인식하면 된다. 잠깐 생명과학1 시간으로 돌아가서 뉴런이 어떻게 작동하는지 알아보자. 이 글에선 가지돌기를 수상돌기라고 생각해주면 좋겠다. . 뉴런은 신경세포체로 세포체에 가지돌기와 축삭돌기가 달려있는 형태를 취하고 있다. 가지돌기 끝에 달린 수용기는 이전 뉴런의 축삭돌기로부터 신경 전달물질인 아세틸콜린을 전달 받는다. 그리고 전달 받은 신호의 빈도가 일정 수준 이상으로 커질때 즉, 역치 이상의 신호가 발생했을 때 역치 이상의 신호들만 축삭돌기까지 신호가 전달된다. 신호가 전달되는 방식까지 설명하면 길어지니 두가지만 기억해보면 좋을 것 같다. . 신호는 일정 수준 이상의 입력값이 있어야만 전달된다. | 전달된 신호는 수치로 환산될 수 있다.(실제 뉴런에선 빈도로써 수치화된다.) | . &#45684;&#47088;&#51032; &#49688;&#54617;&#51201; &#47784;&#45944; . 흔히 뉴런의 연결이라는 모형도를 보면 아래와 같은 그림을 보여준다. 분명 학술적으로 쓰이는 이 그림은 실제가 아니라 단순화 시켜놓은 그림이라는 것을 인지할 필요가 있다. . &gt; 위와 같은 그림을 수학적 모델로 옮겨 놓았다면 첫번째 그림에서 $x_1$만 가중치와 곱하여 활성화 함수에 넣는 프로세스가 될 것이다. 하지만 수학적 모델에서 . $$z = sum{w_k x_k}$$ . $$x^* = a(z)$$ . 과 같이 여러 x를 더하는 이유는 뉴런의 연결이 아래와 같기 때문이다.($x_0$는 이 글에선 상수값으로 취급하겠다.) 각 뉴런의 가지돌기는 하나 이상의 축삭돌기와 연결되어있고, 축삭돌기는 하나 이상의 가지돌기와 연결되어 있다. . 재미있는 점은 6살보다 14살에서 연결 수가 적어진 것이다. 마치 드롭아웃된 것 처럼! . 위와같이 뉴런들끼리 연결되어있는 것을 추상화시킨 것을 인공신경망이라 할 수 있겠다. . . relu = lambda x : max(0, x) sigmoid = lambda x : 1/(1+np.exp(-x)) x = np.linspace(-5, 5, 100) a_relu = [relu(z) for z in x] a_sigmoid = [sigmoid(z) for z in x] sns.set_style(&#39;whitegrid&#39;) fig = plt.figure(figsize=(12,4)) fig.add_subplot(1,2,1) plt.plot(x, a_relu) plt.title(&#39;Rectified Linear Unit&#39;) fig.add_subplot(1,2,2) plt.plot(x, a_sigmoid) plt.title(&#39;Sigmoid&#39;) plt.show() . . 이제 $a$ 함수 즉 활성화 함수에 주목해보자. 활성화 함수의 역할은 실제 뉴런에서 축삭돌기의 최종 신호 전달 역할이다. 실제 뉴런에서는 역치가 존재하여 신호 강도가 역치를 넘지 않으면 전달이 되지 않는 식이었다. 모델링에서도 그와 비슷한 함수가 존재한다. 바로 ReLU 함수이다. (보통 인공신경망의 활성화 함수를 설명할 때엔 $sigmoid = sigma(x) = frac{1}{1+e^{-x}}$ 함수를 이야기 하지만 개인적으론 뉴런을 설명할 때 만큼은 ReLU함수가 개념적으로 더 어울린다고 생각한다.) . ReLU 함수는 rectified linear unit의 약자로 직역하면 정류된 선형 유닛이라고 한다. 여기서 정류라는 뜻의 의미는 +만 흘려보낸다는 뜻이다. 글에서는 활성화 함수를 ReLU함수로 쓰겠다. . 추가) ReLU 함수는 들어오는 z값 즉, 실제 뉴런에서의 신호(빈도)를 받는다. 그리고 일정 수준의 역치(0)를 넘기지 못하는 값은 다음 뉴런으로 전달하지 않는다. 추상적인 수준에서 뉴런의 축삭돌기와 아주 유사하게 작동하는 것을 볼 수 있다. (또한 실제로도 ReLU는 앞서 설명한 이유들과는 다른 이유로 높은 성능을 보이기도 한다.) . 인공신경망은 앞선 뉴런들에서 전달된 값을 받아들여 계산을 한다. 신경망이 꼬인만큼 이 계산이 복잡해 보이는데 어떻게 계산되는지 살펴보자. . 앞서 $z = sum{w_k x_k}$로 두었지만 이는 선형대수를 활용하면 컴퓨터 내부적으로 더욱 쉽게 계산이 가능하다. $$z = bf w^Tx$$ $$a(z) = a( bf w^Tx)$$ 코드로 쓰게 된다면 아래와 같을 것이다. . x = np.array([1, 2, 3]) w = np.array([1.1, 0.9, 1]) z = np.dot(w, x) relu(z) . 5.9 . 인공신경망은 아래 그림과 같이 여러층으로 구성되어있다. 맨 왼쪽 층을 입력층(input layer), 가운데 있는 층들을 은닉층(hidden layer), 가장 오른쪽 층을 출력층(output layer)이라 부른다. . . 우리는 하나의 유닛에 들어오는 계산만이 아니라 여러 유닛들간 계산을 모두 해주어야한다. 그렇다면 데이터가 n개이고 한 층의 유닛이 100개라면 위에서 했던 계산을 100n번 해주어야하는 것일까? 그러고싶진 않을 것이다. 여기서도 선형대수적으로 계산한다면 꽤나 편해진다. . 데이터 셋 $ bf X$를 생각해보자. $ bf X$는 $ bf x^T$들을 열 방향으로 배치한 것으로 생각할 수 있다. . $$ bf X = begin{bmatrix} bf x_1^T bf x_2^T bf x_3^T ... bf x_n^T end{bmatrix}$$입력층에 $ bf X$의 첫번째 데이터 포인트가 들어갈때 첫번째 은닉층의 m개의 유닛들에는 아래의 값이 들어간다 . $$z_{h_1} = bf x_1^T w_{input, 1} $$ . $$z_{h_2} = bf x_1^T w_{input, 2} $$ . $$z_{h_3} = bf x_1^T w_{input, 3} $$ . $$...$$ . $$z_{h_m} = bf x_1^T w_{input, m} $$ . 이를 행렬로 표현하면 아래와 같다. . $$ bf z_h^T = begin{bmatrix} z_{h_1}, z_{h_2}, z_{h_3}, ..., z_{h_m} end{bmatrix} = x_1^T begin{bmatrix} bf w_{input, 1} w_{input, 2} w_{input, 3} ... w_{input, m} end{bmatrix} = x_1^TW_{input, h} $$다음 은닉층으로 전달되는 값들은 . $$ bf a(z_h) = a(x_1^TW_{input, h}) $$가 된다. 이것을 n개의 데이터 포인트로 확장하더라도 선형대수학을 이용하여 아래와 같이 표현할 수 있다. . $$ bf a(Z_h) = a( begin{bmatrix} bf x_1^T bf x_2^T bf x_3^T ... bf x_n^T end{bmatrix}W_{input, h}) = a(XW_{input, h}) $$ 10.2 &#52992;&#46972;&#49828;&#47196; &#45796;&#52789; &#54140;&#49481;&#53944;&#47200; &#44396;&#54788;&#54616;&#44592; . 케라스는 딥러닝 모델의 프로토타입을 빠르고 간단하게 만들고 훈련시킬 수 있는 파이썬의 딥러닝 프레임워크다. 초기에는 빠르게 실험하여 결과를 도출해야했던 연구자들을 위해 개발되었다. . 동일한 코드로 CPU와 GPU모두 실행이 가능하며 사용성 좋은 API를 가지고 있어 모델의 프로토타입을 빠르게 만들 수 있다. CNN과 RNN을 모두 지원하며 둘을 자유롭게 조합하여 사용할 수 있다. 다중 입력, 다중 출력, 층 공유 모델등 웬만한 네트워크 구조는 모두 만들 수 있다. . 모델을 만들기에 앞서 먼저 데이터 세트를 정의해주자. 유명한 fashion_mnist 데이터 세트를 사용하자. . from tensorflow.keras import datasets fashion_mnist = datasets.fashion_mnist (X_train_full, y_train_full), (X_test, y_test) = fashion_mnist.load_data() . X_train_full.shape, y_train_full.shape . ((60000, 28, 28), (60000,)) . X_test.shape, y_test.shape . ((10000, 28, 28), (10000,)) . fig = plt.figure(figsize=(15,8)) for i in range(10): fig.add_subplot(2, 5, i+1) plt.imshow(X_train_full[i]) . X 데이터셋은 0부터 255까지의 값으로 구성되어있다. 이를 0에서 1사이의 값으로 조정해주자. 이 과정을 Normalization이라고 부른다. . X_valid, X_train = X_train_full[:5000]/255.0, X_train_full[5000:]/255.0 y_valid, y_train = y_train_full[:5000], y_train_full[5000:] X_test = X_test/255.0 . fashion_mnist 데이터셋은 레이블에 해당하는 아이템을 나타내기 위해선 클래스 이름의 리스트를 만들어야 한다. . class_names = [&#39;티셔츠&#39;, &#39;트라우저&#39;, &#39;풀오버&#39;, &#39;드레스&#39;, &#39;코트&#39;, &#39;샌달&#39;, &#39;셔츠&#39;, &#39;스니커즈&#39;, &#39;가방&#39;, &#39;엉클부츠&#39;] . fig = plt.figure(figsize=(15,8)) plt.rc(&#39;font&#39;, family=&#39;NanumBarunGothic&#39;) for i in range(10): fig.add_subplot(2, 5, i+1) plt.imshow(X_train[i]) plt.title(class_names[y_train[i]]) . 케라스 작업의 흐름은 대부분 아래와 같이 흘러간다. . 입력 텐서와 타깃 텐서로 이루어진 훈련 데이터를 정의 | 입력과 타깃을 매핑하는 층으로 이루어진 네트워크 또는 모델을 정의 | 손실함수, 옵티마이저, 모니터링하기 위한 측정 지표(예를 들어 accuracy)를 선택하여 학습 과정을 설정 | 훈련 데이터에 대해 모델의 fit() 메서드를 반복적으로 호출 | 모델을 정의하는 방법은 Sequential() 클래스를 사용하는 방법과 함수형 API를 사용하는 방법이다. 여기서는 Sequential 클래스를 사용하여 정의해보자. . from tensorflow.keras import models from tensorflow.keras import layers model = models.Sequential() model.add(layers.Flatten(input_shape=[28,28])) model.add(layers.Dense(512, activation=&#39;relu&#39;)) model.add(layers.Dense(128, activation=&#39;relu&#39;)) model.add(layers.Dense(10, activation=&#39;softmax&#39;)) . model.summary() . Model: &#34;sequential&#34; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= flatten (Flatten) (None, 784) 0 dense (Dense) (None, 512) 401920 dense_1 (Dense) (None, 128) 65664 dense_2 (Dense) (None, 10) 1290 ================================================================= Total params: 468,874 Trainable params: 468,874 Non-trainable params: 0 _________________________________________________________________ . 각 층의 모든 파라미터는 get_weights() 메서드와 set_weights() 메서드를 사용해서 접근할 수 있다. . weights, biases = model.layers[1].get_weights() weights . array([[ 0.06691651, -0.06675828, -0.06246395, ..., -0.03821606, -0.01986468, -0.06652354], [ 0.01525416, -0.05912045, 0.03116538, ..., 0.01423607, -0.01887799, 0.02263939], [-0.00596789, -0.00260571, -0.03378208, ..., -0.03293363, 0.01605745, -0.00529878], ..., [ 0.05126452, 0.00168032, 0.0632956 , ..., 0.00292995, 0.05325491, -0.05367166], [-0.02660308, 0.05614822, -0.01070896, ..., -0.05792694, 0.03024881, 0.02475346], [ 0.01789279, 0.02323135, 0.03835168, ..., -0.0519469 , -0.06122752, 0.02393704]], dtype=float32) . weights.shape . (784, 512) . biases[:10] . array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32) . biases.shape . (512,) . 위와 같이 모델이 만들어지고 만들고나면 컴파일 단계로 넘어간다. 여기서는 모델이 사용할 옵티마이저와 손실함수, 훈련을 위한 측정지표를 지정한다. . from tensorflow.keras import optimizers model.compile(optimizer=optimizers.RMSprop(lr=0.001), loss=&#39;sparse_categorical_crossentropy&#39;, metrics=[&#39;accuracy&#39;]) . /usr/local/lib/python3.7/dist-packages/keras/optimizer_v2/rmsprop.py:130: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead. super(RMSprop, self).__init__(name, **kwargs) . from keras.callbacks import EarlyStopping from keras.callbacks import ModelCheckpoint es = EarlyStopping(monitor=&#39;val_accuracy&#39;, mode=&#39;auto&#39;, verbose=1, patience=7) mc = ModelCheckpoint(&#39;best_model.h5&#39;, monitor=&#39;val_accuracy&#39;, mode=&#39;auto&#39;, save_best_only=True) . 과적합을 방지하거나 모델을 체크포인트를 만들어주는 콜백 객체들은 이 순서에서 정의해준다. . 모델 훈련 준비가 완료되었으니 모델을 훈련해보자. fit()메서드를 호출하면 된다. . history = model.fit(X_train, y_train, epochs=50, batch_size=512, validation_data=(X_valid, y_valid), callbacks=[es, mc]) . Epoch 1/50 108/108 [==============================] - 4s 26ms/step - loss: 0.7365 - accuracy: 0.7408 - val_loss: 0.5399 - val_accuracy: 0.8018 Epoch 2/50 108/108 [==============================] - 3s 24ms/step - loss: 0.4724 - accuracy: 0.8271 - val_loss: 0.4578 - val_accuracy: 0.8366 Epoch 3/50 108/108 [==============================] - 3s 24ms/step - loss: 0.4053 - accuracy: 0.8490 - val_loss: 0.3977 - val_accuracy: 0.8514 Epoch 4/50 108/108 [==============================] - 3s 24ms/step - loss: 0.3654 - accuracy: 0.8637 - val_loss: 0.3367 - val_accuracy: 0.8774 Epoch 5/50 108/108 [==============================] - 3s 24ms/step - loss: 0.3381 - accuracy: 0.8747 - val_loss: 0.4285 - val_accuracy: 0.8324 Epoch 6/50 108/108 [==============================] - 3s 24ms/step - loss: 0.3162 - accuracy: 0.8815 - val_loss: 0.4033 - val_accuracy: 0.8568 Epoch 7/50 108/108 [==============================] - 3s 24ms/step - loss: 0.2996 - accuracy: 0.8869 - val_loss: 0.3225 - val_accuracy: 0.8838 Epoch 8/50 108/108 [==============================] - 3s 30ms/step - loss: 0.2827 - accuracy: 0.8942 - val_loss: 0.3278 - val_accuracy: 0.8780 Epoch 9/50 108/108 [==============================] - 3s 27ms/step - loss: 0.2707 - accuracy: 0.8980 - val_loss: 0.2888 - val_accuracy: 0.8948 Epoch 10/50 108/108 [==============================] - 3s 24ms/step - loss: 0.2599 - accuracy: 0.9019 - val_loss: 0.3068 - val_accuracy: 0.8888 Epoch 11/50 108/108 [==============================] - 3s 24ms/step - loss: 0.2479 - accuracy: 0.9066 - val_loss: 0.3307 - val_accuracy: 0.8812 Epoch 12/50 108/108 [==============================] - 3s 24ms/step - loss: 0.2422 - accuracy: 0.9079 - val_loss: 0.3107 - val_accuracy: 0.8858 Epoch 13/50 108/108 [==============================] - 3s 24ms/step - loss: 0.2308 - accuracy: 0.9120 - val_loss: 0.3429 - val_accuracy: 0.8834 Epoch 14/50 108/108 [==============================] - 4s 33ms/step - loss: 0.2207 - accuracy: 0.9161 - val_loss: 0.3299 - val_accuracy: 0.8876 Epoch 15/50 108/108 [==============================] - 3s 24ms/step - loss: 0.2155 - accuracy: 0.9171 - val_loss: 0.3263 - val_accuracy: 0.8878 Epoch 16/50 108/108 [==============================] - 3s 24ms/step - loss: 0.2064 - accuracy: 0.9218 - val_loss: 0.3094 - val_accuracy: 0.8830 Epoch 00016: early stopping . history의 history는 딕셔너리 형태로 훈련 과정의 데이터가 저장되어있습니다. . import pandas as pd hs = pd.DataFrame(history.history) hs.plot(figsize=(15,4)) plt.ylim(0,1) . (0.0, 1.0) . 훈련된 모델을 테스트 세트로 평가하려면 evaluate() 메서드를 호출하면 된다. . model.evaluate(X_test, y_test) . 313/313 [==============================] - 1s 3ms/step - loss: 0.3597 - accuracy: 0.8706 . [0.3597263991832733, 0.8705999851226807] . 모델의 predict() 메서드를 호출하면 새로운 샘플에 대해 예측을 만들 수 있다. . X_new = X_test[50:53] y_proba = model.predict(X_new) y_proba.round(2) . array([[0. , 0. , 0.03, 0. , 0.96, 0. , 0.01, 0. , 0. , 0. ], [0. , 0. , 0.61, 0. , 0.19, 0. , 0.19, 0. , 0. , 0. ], [0. , 0. , 0. , 0. , 0. , 1. , 0. , 0. , 0. , 0. ]], dtype=float32) . 확률이 아닌 클래스 추정을 위해선 아래와 같이 하자. . y_pred = np.argmax(y_proba, axis=-1) y_pred . array([4, 2, 5]) . np.array(class_names)[y_pred] . array([&#39;코트&#39;, &#39;풀오버&#39;, &#39;샌달&#39;], dtype=&#39;&lt;U4&#39;) . fig = plt.figure(figsize=(15,4)) fig.add_subplot(1,3,1); plt.imshow(X_new[0]) fig.add_subplot(1,3,2); plt.imshow(X_new[1]) fig.add_subplot(1,3,3); plt.imshow(X_new[2]) . &lt;matplotlib.image.AxesImage at 0x7f8e3577e390&gt; . 10.3 &#49888;&#44221;&#47581; &#54616;&#51060;&#54140;&#54028;&#46972;&#48120;&#53552; &#53916;&#45789;&#54616;&#44592; . 신경망에는 들어가는 하이퍼파라미터가 많아 유연한 만큼 조정할 하이퍼 파라미터도 많다. 어떤 하이퍼파라미터 조합이 좋을지 알아보는 방법으로는 KFold를 통해 가장 좋은 점수를 갖는 조합을 알아보는 것이다. GridSearchCV나 RandomizedSearchCV를 통해 하이퍼파라미터 공간을 탐색해볼 수도 있을 것이다. . 각 하이퍼파라미터가 어떤 역할을 하는지 어떻게 조정하면 좋을지 이론적, 경험적으로 알고있는 것이 좋을 수도 있으니 알아보자. . 알아볼 하이퍼파라미터의 종류는 아래와 같다. . 은닉층 개수 | 은닉층의 뉴런 개수 | 옵티마이저 | 학습률 | 배치크기 | 활성화 함수 | 에포크 수 | 1. &#51008;&#45769;&#52789; &#44060;&#49688; . 일반 근사이론 또는 시벤코 정리라 불리는 이론에 따르면 은닉층이 하나뿐인 다층 퍼셉트론이더라도 뉴런개수가 충분하다면 아주 복잡한 함수도 모델링할 수 있다. 하지만 복잡한 문제에서는 심층 신경망이 얕은 신경망보다 파라미터의 효율성이 좋다. 다시 말해서 뉴런을 좁고 깊게 쌓은 심층 신경망은 뉴런을 넓고 얕게 쌓은 신경망보다 같은 성능을 내기위한 뉴런의 수가 적다. 그래서 은닉층은 좁고 깊게 쌓는 것이 일반적이다. . 2. &#51008;&#45769;&#52789;&#51032; &#45684;&#47088; &#44060;&#49688; . 은닉층의 구성 방식은 일반적으로 각 층의 뉴런의 개수를 점점 줄여서 깔때기처럼 구성한다. 저수준의 많은 특성들이 고수준의 적은 특성으로 요약될 수 있기 때문이다. 그런데 요즘엔 이 구성이 일반적이지 않다고 한다. 대부분의 경우에 모든 층에 같은 크기를 주어도 동일하거나 나은 성능을 내며 이 경우 층별로 튜닝했어야할 하이퍼파라미터를 하나로 조정할 수 있게되어 편해진다. . 데이터셋에 따라서는 첫 번째 은닉층을 크게 하는 것이 도움될 때도 있다고 한다. . 또는 아주 큰 뉴런개수를 선택한 후 조기종료나 드롭아웃과 같은 규제 기법을 사용하는 것이 간단하고 효과적이라고 한다. 이 방식을 사용하면 모델에서 문제를 일으킬 수 있는 병목층을 피할수도 있다고 한다. . 일반적으로 층의 뉴런 개수보다 층 수를 늘리는 쪽이 이득이 많다고 한다. . 1, 2를 종합해보면 경험적으로 크다고 생각되는 뉴런 개수로 조기종료나 드롭아웃과 같은 규제기법을 적용하여 깊게 쌓는 것이 좋아보인다. . 3.&#50741;&#54000;&#47560;&#51060;&#51200; . 아래의 깃허브 참고 . 파이토치 옵티마이저 . 4. &#54617;&#49845;&#47456; . 일반적으로 최적의 학습률은 훈련 알고리즘이 발산하는 학습률의 절반 정도라고한다. 그 외에도 딱 하나의 학습률이 아닌 스케쥴러를 이용한 방법을 사용할 수도 있다. 학습률을 크게 시작해서 점점 낮은 학습률로 가는 방법이나 큰 학습률에서 작은 학습률까지 가는 과정을 반복하는 방법 등으로 최적점을 찾아갈 수 있다. . 5. &#48176;&#52824; &#53356;&#44592; . 배치 크기는 모델의 성능과 훈련시간에 큰 영향을 주는 하이퍼 파라미터이다. 큰 배치 크기를 사용한다면 GPU와 같은 하드웨어 가속기를 효율적으로 활용하여 초당 더 많은 샘플을 처리할 수 있게된다. 많은 연구자들이나 기술자들은 GPU 램에 맞는 가장 큰 배치 크기를 사용하라고 권장하나 주의할 점이 있다. 너무 큰 배치 크기를 사용하면 훈련 초기에 불안정하게 훈련될 수 있다는 점이다. 그 경우 작은 배치 크기로 훈련된 모델보다 일반화 성능이 좋지 않을 수 있다. 연구자들 대부분의 의견은 작은 배치 크기(2~32)를 사용하여 일정 수준의 일반화 성능을 낸 후 학습률 예열과 같은 방법과 같이 큰 배치크기를 사용하는 것을 권장한다. . 6. &#54876;&#49457;&#54868; &#54632;&#49688; . 앞서 ReLU 활성화 함수가 실제 뉴런의 축삭돌기와 작동방식이 비슷하다고 언급하였다. 실제로 성능도 아주 뛰어난 편이나 최근에는 ReLU이외에도 Leaky ReLU나 ELU등의 ReLU를 개량한 버젼이 많이 등장하고 있다. 그중에서 ELU는 최근에 &quot;잘 모르겠으면 ELU를 써라&quot;라는 말이 돌 정도로 옵티마이저로 치면 RAdam과 같은 취급을 받는 것으로 알려져있다. . 7. &#48152;&#48373;&#54943;&#49688; . 조기 종료를 사용한다. . &#52280;&#44256;&#47928;&#54732; . 핸즈온 머신러닝 | 케라스 창시자에게 배우는 딥러닝 | 블로그 - 가장 단순한 신경망을 통한 작동원리 | 블로그 - 뉴런이란? |",
            "url": "https://edypidy.github.io/studyblog/deep_learning/2022/01/01/SSUDA-_Chapter_10_%EC%BC%80%EB%9D%BC%EC%8A%A4%EB%A5%BC_%EC%82%AC%EC%9A%A9%ED%95%9C_%EC%9D%B8%EA%B3%B5_%EC%8B%A0%EA%B2%BD%EB%A7%9D_%EC%86%8C%EA%B0%9C.html",
            "relUrl": "/deep_learning/2022/01/01/SSUDA-_Chapter_10_%EC%BC%80%EB%9D%BC%EC%8A%A4%EB%A5%BC_%EC%82%AC%EC%9A%A9%ED%95%9C_%EC%9D%B8%EA%B3%B5_%EC%8B%A0%EA%B2%BD%EB%A7%9D_%EC%86%8C%EA%B0%9C.html",
            "date": " • Jan 1, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "[SSUDA][Kaggle Review] Predict Future Sales",
            "content": "Intro . 본 글은 kaggle의 Predict Future Sales 대회의 데이터를 사용하였으며 아래의 코드를 대부분 필사 및 의역하였습니다. . Model stacking, feature engineering and EDA | Deep Learning for Time Series Forecasting | Time-series forecasting with LSTM autoencoders | . Predict future sales . 가게 품목들의 다음 달 총 판매량을 예측하는 대회입니다. . 주어진 데이터는 매일의 판매량 데이터입니다. test 데이터 내 모든 가게들의 물건별 총 판매량을 예측해야합니다. . test 데이터 내의 가게들과 물건들은 매달 아주 살짝 달라지는 것을 주의해야합니다. 달라진다고 하더라도 깨지지 않는 모델을 잘 만드는 것이 필요하겠습니다. . Data Description . ID - an Id that represents a (Shop, Item) tuple within the test set | shop_id - unique identifier of a shop | item_id - unique identifier of a product | item_category_id - unique identifier of item category | item_cnt_day - number of products sold. You are predicting a monthly amount of this measure | item_price - current price of an item | date - date in format dd/mm/yyyy | date_block_num - a consecutive month number, used for convenience. January 2013 is 0, February 2013 is 1,..., October 2015 is 33 | item_name - name of item | shop_name - name of shop | item_category_name - name of item category | . Load Libraries . from google.colab import drive drive.mount(&#39;/content/drive&#39;) import warnings, os, random import datetime import numpy as np import pandas as pd from tqdm import tqdm import seaborn as sns import matplotlib.pyplot as plt !pip install catboost from catboost import Pool from catboost import CatBoostRegressor from xgboost import XGBRegressor from xgboost import plot_importance from sklearn.linear_model import LinearRegression from sklearn.neighbors import KNeighborsRegressor from sklearn.ensemble import RandomForestRegressor from sklearn.preprocessing import StandardScaler, MinMaxScaler from sklearn.metrics import mean_squared_error from sklearn.model_selection import train_test_split import tensorflow as tf import tensorflow.keras.layers as L from tensorflow.keras import optimizers, Sequential, Model from tensorflow.keras.utils import plot_model from keras.layers.convolutional import Conv1D, MaxPooling1D from tensorflow.keras.layers import Dense, LSTM, RepeatVector, TimeDistributed, Flatten import plotly as py import plotly.graph_objs as go from plotly.offline import init_notebook_mode, iplot %matplotlib inline sns.set_palette(&#39;deep&#39;) sns.set_color_codes() sns.set(style=&#39;darkgrid&#39;) warnings.filterwarnings(action=&#39;ignore&#39;) pd.set_option(&#39;display.float_format&#39;, lambda x: &#39;%.2f&#39; % x) init_notebook_mode(connected=True) # 재현가능한 실험을 위해 Set seed 함수를 만듭니다. def seed_everything(seed=0): random.seed(seed) np.random.seed(seed) tf.random.set_seed(seed) os.environ[&#39;PYTHONHASHSEED&#39;] = str(seed) os.environ[&#39;TF_DETERMINISTIC_OPS&#39;] = &#39;1&#39; seed = 0 seed_everything(seed) ## Set Drive Path path=&quot;/content/drive/MyDrive/my_data/kaggle_study/Predict_Future_Sales/&quot; . . Load Data . sales = pd.read_csv(path + &#39;sales_train.csv&#39;, parse_dates=[&#39;date&#39;], dtype={&#39;date&#39;: &#39;str&#39;, &#39;date_block_num&#39;: &#39;int32&#39;, &#39;shop_id&#39;: &#39;int32&#39;, &#39;item_id&#39;: &#39;int32&#39;, &#39;item_price&#39;: &#39;float32&#39;, &#39;item_cnt_day&#39;: &#39;int32&#39;}) test = pd.read_csv(path + &#39;test.csv&#39;, dtype={&#39;ID&#39;: &#39;int32&#39;, &#39;shop_id&#39;: &#39;int32&#39;}) shops = pd.read_csv(path + &#39;shops.csv&#39;, dtype={&#39;shop_name&#39;: &#39;str&#39;, &#39;shop_id&#39;: &#39;int32&#39;}) items = pd.read_csv(path + &#39;items.csv&#39;, dtype={&#39;item_name&#39;: &#39;str&#39;, &#39;item_id&#39;: &#39;int32&#39;, &#39;item_category_id&#39;: &#39;int32&#39;}) item_categories = pd.read_csv(path + &#39;item_categories.csv&#39;, dtype={&#39;item_category_name&#39;: &#39;str&#39;, &#39;item_category_id&#39;: &#39;int32&#39;}) . . # Join data sets train = sales.join(items, on=&#39;item_id&#39;, rsuffix=&#39;_&#39;).join(shops, on=&#39;shop_id&#39;, rsuffix=&#39;_&#39;).join(item_categories, on=&#39;item_category_id&#39;, rsuffix=&#39;_&#39;) train.drop([&#39;item_id_&#39;, &#39;shop_id_&#39;, &#39;item_category_id_&#39;], axis=1, inplace=True) . . Peek . print(&#39;Train Shape : &#39;, train.shape) . . Train Shape : (2935849, 10) . train.head().T . . 0 1 2 3 4 . date 2013-02-01 00:00:00 | 2013-03-01 00:00:00 | 2013-05-01 00:00:00 | 2013-06-01 00:00:00 | 2013-01-15 00:00:00 | . date_block_num 0 | 0 | 0 | 0 | 0 | . shop_id 59 | 25 | 25 | 25 | 25 | . item_id 22154 | 2552 | 2552 | 2554 | 2555 | . item_price 999.00 | 899.00 | 899.00 | 1709.05 | 1099.00 | . item_cnt_day 1 | 1 | -1 | 1 | 1 | . item_name ЯВЛЕНИЕ 2012 (BD) | DEEP PURPLE The House Of Blue Light LP | DEEP PURPLE The House Of Blue Light LP | DEEP PURPLE Who Do You Think We Are LP | DEEP PURPLE 30 Very Best Of 2CD (Фирм.) | . item_category_id 37 | 58 | 58 | 58 | 56 | . shop_name Ярославль ТЦ &quot;Альтаир&quot; | Москва ТРК &quot;Атриум&quot; | Москва ТРК &quot;Атриум&quot; | Москва ТРК &quot;Атриум&quot; | Москва ТРК &quot;Атриум&quot; | . item_category_name Кино - Blu-Ray | Музыка - Винил | Музыка - Винил | Музыка - Винил | Музыка - CD фирменного производства | . train.describe() . . date_block_num shop_id item_id item_price item_cnt_day item_category_id . count 2935849.00 | 2935849.00 | 2935849.00 | 2935849.00 | 2935849.00 | 2935849.00 | . mean 14.57 | 33.00 | 10197.23 | 890.62 | 1.24 | 40.00 | . std 9.42 | 16.23 | 6324.30 | 1726.44 | 2.62 | 17.10 | . min 0.00 | 0.00 | 0.00 | -1.00 | -22.00 | 0.00 | . 25% 7.00 | 22.00 | 4476.00 | 249.00 | 1.00 | 28.00 | . 50% 14.00 | 31.00 | 9343.00 | 399.00 | 1.00 | 40.00 | . 75% 23.00 | 47.00 | 15684.00 | 999.00 | 1.00 | 55.00 | . max 33.00 | 59.00 | 22169.00 | 307980.00 | 2169.00 | 83.00 | . print(&#39;Min date from train set : %s&#39;%train[&#39;date&#39;].min().date()) print(&#39;Max date from train set : %s&#39;%train[&#39;date&#39;].max().date()) . . Min date from train set : 2013-01-01 Max date from train set : 2015-12-10 . Caution : Data leakages . Data leakage에 대해선 test set에 나와있는 &#39;shop_id&#39;. &#39;item_id&#39;만을 사용하겠습니다. . test_shop_ids = test[&#39;shop_id&#39;].unique() test_item_ids = test[&#39;item_id&#39;].unique() # test set에만 존재하는 shops lk_train = train[train[&#39;shop_id&#39;].isin(test_shop_ids)] # test set에만 존재하는 items lk_train = lk_train[lk_train[&#39;item_id&#39;].isin(test_item_ids)] . print(&#39;Data set size before leaking : &#39;, train.shape[0]) print(&#39;Data set size after leaking : &#39;, lk_train.shape[0]) . Data set size before leaking : 2935849 Data set size after leaking : 1224439 . Data cleaning . &#39;item_price &gt; 0&#39; 이어야합니다 . train = train.query(&#39;item_price &gt; 0&#39;) . Data preprocessing . text 피쳐들로는 아무것도 하지 않을 것이니 드롭해줍니다. | 문제는 다음 달의 총 판매량 예측을 하는 것입니다. 하지만 주어진 데이터는 일별 데이터입니다. 원치않는 컬럼은 제거하고 월 단위로 합쳐보겠습니다. | . train_monthly = lk_train[[&#39;date&#39;, &#39;date_block_num&#39;, &#39;shop_id&#39;, &#39;item_category_id&#39;, &#39;item_id&#39;, &#39;item_price&#39;, &#39;item_cnt_day&#39;]] . train_monthly = train_monthly.sort_values(&#39;date&#39;).groupby([&#39;date_block_num&#39;, &#39;shop_id&#39;, &#39;item_category_id&#39;, &#39;item_id&#39;], as_index=False) train_monthly = train_monthly.agg({&#39;item_price&#39; : [&#39;sum&#39;, &#39;mean&#39;], &#39;item_cnt_day&#39; : [&#39;sum&#39;, &#39;mean&#39;, &#39;count&#39;]}) # agg함수 애용해야겠습니다.. # Rename Features train_monthly.columns = [&#39;date_block_num&#39;, &#39;shop_id&#39;, &#39;item_category_id&#39;, &#39;item_id&#39;, &#39;item_price&#39;, &#39;mean_item_price&#39;, &#39;item_cnt&#39;, &#39;mean_item_cnt&#39;, &#39;transactions&#39;] . 실제 데이터와 유사하게 하기위해서 로드된 데이터 세트로부터 결측값을 생성할 필요가 있습니다. 그러니 각 shop과 item마다 결측된 데이터를 생성해줍시다.(딱히 결측된 데이터를 갖고있는 것은 아니니 0으로 대체해봅니다.) . shop_ids = train_monthly[&#39;shop_id&#39;].unique() item_ids = train_monthly[&#39;item_id&#39;].unique() empty_df = [] for i in range(34): # 2013-Jan:0 ~ 2015-Dec:33 for shop in shop_ids: for item in item_ids: empty_df.append([i, shop, item]) empty_df = pd.DataFrame(empty_df, columns=[&#39;date_block_num&#39;, &#39;shop_id&#39;, &#39;item_id&#39;]) . train_monthly = pd.merge(empty_df, train_monthly, on=[&#39;date_block_num&#39;, &#39;shop_id&#39;, &#39;item_id&#39;], how=&#39;left&#39;) train_monthly.fillna(0, inplace=True) . 이렇게 함으로써 (shop, item) 쌍의 데이터 형태가 동일해집니다. 새로운 데이터 세트를 한번 봅시다. . train_monthly.head().T . 0 1 2 3 4 . date_block_num 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . shop_id 2.00 | 2.00 | 2.00 | 2.00 | 2.00 | . item_id 5572.00 | 5643.00 | 5583.00 | 7893.00 | 7894.00 | . item_category_id 2.00 | 2.00 | 5.00 | 6.00 | 6.00 | . item_price 10730.00 | 4775.21 | 1188.30 | 5970.00 | 1490.00 | . mean_item_price 1532.86 | 2387.60 | 594.15 | 1990.00 | 1490.00 | . item_cnt 9.00 | 0.00 | 2.00 | 3.00 | 1.00 | . mean_item_cnt 1.29 | 0.00 | 1.00 | 1.00 | 1.00 | . transactions 7.00 | 2.00 | 2.00 | 3.00 | 1.00 | . train_monthly.describe().T . count mean std min 25% 50% 75% max . date_block_num 6734448.00 | 16.50 | 9.81 | 0.00 | 8.00 | 16.50 | 25.00 | 33.00 | . shop_id 6734448.00 | 31.64 | 17.56 | 2.00 | 16.00 | 34.50 | 47.00 | 59.00 | . item_id 6734448.00 | 11041.89 | 6210.74 | 30.00 | 5385.25 | 11265.50 | 16068.25 | 22167.00 | . item_category_id 6734448.00 | 3.79 | 13.21 | 0.00 | 0.00 | 0.00 | 0.00 | 83.00 | . item_price 6734448.00 | 187.35 | 2171.80 | 0.00 | 0.00 | 0.00 | 0.00 | 515573.59 | . mean_item_price 6734448.00 | 81.13 | 531.16 | 0.00 | 0.00 | 0.00 | 0.00 | 42990.00 | . item_cnt 6734448.00 | 0.24 | 3.46 | -4.00 | 0.00 | 0.00 | 0.00 | 2253.00 | . mean_item_cnt 6734448.00 | 0.10 | 0.61 | -2.00 | 0.00 | 0.00 | 0.00 | 1000.00 | . transactions 6734448.00 | 0.18 | 0.90 | 0.00 | 0.00 | 0.00 | 0.00 | 31.00 | . train_monthly[&#39;year&#39;] = train_monthly[&#39;date_block_num&#39;].apply(lambda x: ((x//12)+2013)) train_monthly[&#39;month&#39;] = train_monthly[&#39;date_block_num&#39;].apply(lambda x: (x % 12)) . train_monthly . date_block_num shop_id item_id item_category_id item_price mean_item_price item_cnt mean_item_cnt transactions year month . 0 0 | 2 | 5572 | 2.00 | 10730.00 | 1532.86 | 9.00 | 1.29 | 7.00 | 2013 | 0 | . 1 0 | 2 | 5643 | 2.00 | 4775.21 | 2387.60 | 0.00 | 0.00 | 2.00 | 2013 | 0 | . 2 0 | 2 | 5583 | 5.00 | 1188.30 | 594.15 | 2.00 | 1.00 | 2.00 | 2013 | 0 | . 3 0 | 2 | 7893 | 6.00 | 5970.00 | 1990.00 | 3.00 | 1.00 | 3.00 | 2013 | 0 | . 4 0 | 2 | 7894 | 6.00 | 1490.00 | 1490.00 | 1.00 | 1.00 | 1.00 | 2013 | 0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 6734443 33 | 36 | 9103 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | . 6734444 33 | 36 | 9107 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | . 6734445 33 | 36 | 5704 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | . 6734446 33 | 36 | 12733 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | . 6734447 33 | 36 | 15925 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | . 6734448 rows × 11 columns . EDA . # Grouping data for EDA gp_month_mean = train_monthly.groupby([&#39;month&#39;], as_index=False)[&#39;item_cnt&#39;].mean() gp_month_sum = train_monthly.groupby([&#39;month&#39;], as_index=False)[&#39;item_cnt&#39;].sum() gp_category_mean = train_monthly.groupby([&#39;item_category_id&#39;], as_index=False)[&#39;item_cnt&#39;].mean() gp_category_sum = train_monthly.groupby([&#39;item_category_id&#39;], as_index=False)[&#39;item_cnt&#39;].sum() gp_shop_mean = train_monthly.groupby([&#39;shop_id&#39;], as_index=False).mean() gp_shop_sum = train_monthly.groupby([&#39;shop_id&#39;], as_index=False).sum() . . fig, axes = plt.subplots(2, 1, figsize=(22,10), sharex=True) # sharex라는 option이 있었군요.. fig.patch.set_facecolor(&#39;#eaeaf2&#39;) sns.lineplot(x=&#39;month&#39;, y=&#39;item_cnt&#39;, data=gp_month_mean, ax=axes[0]).set_title(&#39;Monthly mean&#39;, fontsize=20, fontweight=&#39;bold&#39;) sns.lineplot(x=&#39;month&#39;, y=&#39;item_cnt&#39;, data=gp_month_sum, ax=axes[1]).set_title(&#39;Monthly sum&#39;, fontsize=20, fontweight=&#39;bold&#39;) . . Text(0.5, 1.0, &#39;Monthly sum&#39;) . 위에서 볼 수 있듯이 연말로 갈수록 item sales count가(mean) 커지는 경향이 있습니다. 그렇다면 어떤 category의 item이 더 많이 팔릴까요? . fig, axes = plt.subplots(2, 1, figsize=(22,10), sharex=True) fig.patch.set_facecolor(&#39;#eaeaf2&#39;) sns.barplot(x=&#39;item_category_id&#39;, y=&#39;item_cnt&#39;, data=gp_category_mean, ax=axes[0], palette=&#39;rocket&#39;).set_title(&#39;Category mean&#39;, fontsize=20, fontweight=&#39;bold&#39;) sns.barplot(x=&#39;item_category_id&#39;, y=&#39;item_cnt&#39;, data=gp_category_sum, ax=axes[1], palette=&#39;rocket&#39;).set_title(&#39;Category sum&#39;, fontsize=20, fontweight=&#39;bold&#39;) . . Text(0.5, 1.0, &#39;Category sum&#39;) . 평균적으로 많이 팔린 몇몇의 item이 보이고 그에 반해 총 판매량이 큰 item들이 보입니다. 아무래도 몇몇 item이 대부분의 sell count를 차지하는 것 같습니다. . 이번에는 어떤 가게가 많은 판매량을 갖는지 보겠습니다. . fig, axes = plt.subplots(2, 1, figsize=(22,10), sharex=True) fig.patch.set_facecolor(&#39;#eaeaf2&#39;) sns.barplot(x=&#39;shop_id&#39;, y=&#39;item_cnt&#39;, data=gp_shop_mean, ax=axes[0], palette=&#39;rocket&#39;).set_title(&#39;Shop mean&#39;, fontsize=20, fontweight=&#39;bold&#39;) sns.barplot(x=&#39;shop_id&#39;, y=&#39;item_cnt&#39;, data=gp_shop_sum, ax=axes[1], palette=&#39;rocket&#39;).set_title(&#39;Shop sum&#39;, fontsize=20, fontweight=&#39;bold&#39;) . . Text(0.5, 1.0, &#39;Shop sum&#39;) . 대부분의 shop들은 비슷한 비율의 판매율을 보이고, 세 군데 정도의 shop에서 높은 판매율을 보이네요. 아마 shop의 크기를 암시적으로 의미할 것 같습니다. . Checking for outliers . sns.jointplot(x=&#39;item_cnt&#39;, y=&#39;item_price&#39;, data=train_monthly, height=8) . . &lt;seaborn.axisgrid.JointGrid at 0x7fbc3c235410&gt; . sns.jointplot(x=&#39;item_cnt&#39;, y=&#39;transactions&#39;, data=train_monthly, height=8) . . &lt;seaborn.axisgrid.JointGrid at 0x7fbbc40a4490&gt; . &#39;item_cnt&#39;의 분포를 보겠습니다. . fig = plt.figure(figsize=(22,6)) fig.patch.set_facecolor(&#39;#eaeaf2&#39;) sns.boxplot(train_monthly[&#39;item_cnt&#39;]) . . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fbbc3eebf90&gt; . Removing outliers . &#39;item_cnt &gt; 20 and &lt; 0&#39;와 &#39;item_price &gt;= 400_000&#39;을 outliers로 잡고 제거하겠습니다. . 이 글에선 outlier에 대한 기준이 딱히 밝혀지진 않았습니다. 다른 근거를 통해 outlier를 재설정하여 분석하는 것도 괜찮아 보입니다. . train_monthly = train_monthly.query(&#39;item_cnt &gt;= 0 and item_cnt &lt;= 20 and item_price &lt; 400000&#39;) . Creating the label . 예측해야할 레이블은 다음달의 총 판매량입니다. . train_monthly[&#39;item_cnt_month&#39;] = train_monthly.sort_values(&#39;date_block_num&#39;).groupby([&#39;shop_id&#39;, &#39;item_id&#39;])[&#39;item_cnt&#39;].shift(-1) # pd.DataFrame.shift(n) 메소드는 n칸씩 뒤로 밀어줍니다. -1칸이면 앞으로 당깁니다. 아래의 결과를 보면 더욱 명확해집니다. . train_monthly.query(&#39;shop_id == 2 and item_id == 5572&#39;).head(3) . date_block_num shop_id item_id item_category_id item_price mean_item_price item_cnt mean_item_cnt transactions year month item_cnt_month . 0 0 | 2 | 5572 | 2.00 | 10730.00 | 1532.86 | 9.00 | 1.29 | 7.00 | 2013 | 0 | 1.00 | . 198072 1 | 2 | 5572 | 2.00 | 1590.00 | 1590.00 | 1.00 | 1.00 | 1.00 | 2013 | 1 | 1.00 | . 396144 2 | 2 | 5572 | 2.00 | 1490.00 | 1490.00 | 1.00 | 1.00 | 1.00 | 2013 | 2 | 2.00 | . Feature Engineering . item의 가격이 구매 개수에 따라 달라집니다. 단위를 맞추어 item price 컬럼을 만들겠습니다. . train_monthly[&#39;item_price_unit&#39;] = train_monthly[&#39;item_price&#39;] // train_monthly[&#39;item_cnt&#39;] train_monthly[&#39;item_price_unit&#39;].fillna(0, inplace=True) . item을 판매하는 곳은 한 곳이 아닙니다. 여러 가게들의 가격 동향을 반영하기 위해 최고가와 최저가 컬럼을 추가하겠습니다. . gp_item_price = train_monthly.sort_values(&#39;date_block_num&#39;).groupby([&#39;item_id&#39;], as_index=False).agg({&#39;item_price&#39;:[np.min, np.max]}) gp_item_price.columns = [&#39;item_id&#39;, &#39;hist_min_item_price&#39;, &#39;hist_max_item_price&#39;] train_monthly = pd.merge(train_monthly, gp_item_price, how=&#39;left&#39;, on=&#39;item_id&#39;) . 얼마나 item들의 과거 최저가, 최고가로부터 가격에 변동이 있는지 반영하겠습니다. . train_monthly[&#39;price_increase&#39;] = train_monthly[&#39;item_price&#39;] - train_monthly[&#39;hist_min_item_price&#39;] train_monthly[&#39;price_decrease&#39;] = train_monthly[&#39;hist_max_item_price&#39;] - train_monthly[&#39;item_price&#39;] . Rolling window 기반의 피쳐들을 생성합니다.(window = 3 months) . Rolling window는 시계열 데이터를 다룰때 자주 사용되는 기법입니다. window=3이니 원래라면, 맨 처음 2달간의 데이터엔 NA값이 생성됩니다. min_periods=1을 설정해줌으로써 첫달부터 NA값이 생성되지 않습니다. . f_min = lambda x: x.rolling(window=3, min_periods=1).min() # Max value f_max = lambda x: x.rolling(window=3, min_periods=1).max() # Mean value f_mean = lambda x: x.rolling(window=3, min_periods=1).mean() # Standard value f_std = lambda x: x.rolling(window=3, min_periods=1).std() function_list = [f_min, f_max, f_mean, f_std] function_name = [&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;, &#39;std&#39;] for i in range(len(function_list)): train_monthly[(&#39;item_cnt_%s&#39; % function_name[i])] = train_monthly.sort_values(&#39;date_block_num&#39;).groupby([&#39;shop_id&#39;, &#39;item_category_id&#39;, &#39;item_id&#39;])[&#39;item_cnt&#39;].apply(function_list[i]) # std feature의 empty값을 0으로 채워줍니다. train_monthly[&#39;item_cnt_std&#39;].fillna(0, inplace=True) . Lag based features . 오늘의 게으름이 당장 내일의 인생에만 반영되지는 않습니다. 먼 미래에도 반영될 수 있는 것이죠. . lag_list = [1, 2, 3] for lag in lag_list: ft_name = (&#39;item_cnt_shifted%s&#39; % lag) train_monthly[ft_name] = train_monthly.sort_values(&#39;date_block_num&#39;).groupby([&#39;shop_id&#39;, &#39;item_category_id&#39;, &#39;item_id&#39;])[&#39;item_cnt&#39;].shift(lag) # shift된 feature들의 결측값을 0으로 대체합니다. train_monthly[ft_name].fillna(0, inplace=True) . Item sales count trend &gt; . train_monthly[&#39;item_trend&#39;] = train_monthly[&#39;item_cnt&#39;] for lag in lag_list: ft_name = (&#39;item_cnt_shifted%s&#39; % lag) train_monthly[&#39;item_trend&#39;] -= train_monthly[ft_name] # 다 더한다음에 나누는건 이해 가는데 빼는건 뭔가 싶지만 일단 넘어가겠습니다.. train_monthly[&#39;item_trend&#39;] /= len(lag_list) + 1 . Dataset after feature engineering . train_monthly.head().T . 0 1 2 3 4 . date_block_num 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . shop_id 2.00 | 2.00 | 2.00 | 2.00 | 2.00 | . item_id 5572.00 | 5643.00 | 5583.00 | 7893.00 | 7894.00 | . item_category_id 2.00 | 2.00 | 5.00 | 6.00 | 6.00 | . item_price 10730.00 | 4775.21 | 1188.30 | 5970.00 | 1490.00 | . mean_item_price 1532.86 | 2387.60 | 594.15 | 1990.00 | 1490.00 | . item_cnt 9.00 | 0.00 | 2.00 | 3.00 | 1.00 | . mean_item_cnt 1.29 | 0.00 | 1.00 | 1.00 | 1.00 | . transactions 7.00 | 2.00 | 2.00 | 3.00 | 1.00 | . year 2013.00 | 2013.00 | 2013.00 | 2013.00 | 2013.00 | . month 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . item_cnt_month 1.00 | 0.00 | 1.00 | 2.00 | 2.00 | . item_price_unit 1192.00 | inf | 594.00 | 1990.00 | 1490.00 | . hist_min_item_price 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . hist_max_item_price 18979.50 | 35260.00 | 5592.00 | 27950.00 | 25880.00 | . price_increase 10730.00 | 4775.21 | 1188.30 | 5970.00 | 1490.00 | . price_decrease 8249.50 | 30484.79 | 4403.70 | 21980.00 | 24390.00 | . item_cnt_min 9.00 | 0.00 | 2.00 | 3.00 | 1.00 | . item_cnt_max 9.00 | 0.00 | 2.00 | 3.00 | 1.00 | . item_cnt_mean 9.00 | 0.00 | 2.00 | 3.00 | 1.00 | . item_cnt_std 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . item_cnt_shifted1 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . item_cnt_shifted2 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . item_cnt_shifted3 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . item_trend 2.25 | 0.00 | 0.50 | 0.75 | 0.25 | . train_monthly.describe().T . count mean std min 25% 50% 75% max . date_block_num 6728118.00 | 16.50 | 9.81 | 0.00 | 8.00 | 16.00 | 25.00 | 33.00 | . shop_id 6728118.00 | 31.64 | 17.56 | 2.00 | 16.00 | 35.00 | 47.00 | 59.00 | . item_id 6728118.00 | 11042.87 | 6209.70 | 30.00 | 5386.00 | 11266.00 | 16068.00 | 22167.00 | . item_category_id 6728118.00 | 3.75 | 13.16 | 0.00 | 0.00 | 0.00 | 0.00 | 83.00 | . item_price 6728118.00 | 169.77 | 1792.01 | 0.00 | 0.00 | 0.00 | 0.00 | 366860.00 | . mean_item_price 6728118.00 | 79.71 | 522.27 | 0.00 | 0.00 | 0.00 | 0.00 | 42990.00 | . item_cnt 6728118.00 | 0.19 | 0.91 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . mean_item_cnt 6728118.00 | 0.09 | 0.31 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . transactions 6728118.00 | 0.17 | 0.74 | 0.00 | 0.00 | 0.00 | 0.00 | 19.00 | . year 6728118.00 | 2013.94 | 0.80 | 2013.00 | 2013.00 | 2014.00 | 2015.00 | 2015.00 | . month 6728118.00 | 5.21 | 3.32 | 0.00 | 2.00 | 5.00 | 8.00 | 11.00 | . item_cnt_month 6530047.00 | 0.19 | 0.91 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_price_unit 6728118.00 | inf | nan | 0.00 | 0.00 | 0.00 | 0.00 | inf | . hist_min_item_price 6728118.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . hist_max_item_price 6728118.00 | 5561.39 | 11482.78 | 0.00 | 1043.00 | 2408.00 | 5592.00 | 366860.00 | . price_increase 6728118.00 | 169.77 | 1792.01 | 0.00 | 0.00 | 0.00 | 0.00 | 366860.00 | . price_decrease 6728118.00 | 5396.74 | 11022.27 | 0.00 | 999.00 | 2396.00 | 5490.00 | 366860.00 | . item_cnt_min 6728118.00 | 0.14 | 0.69 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_max 6728118.00 | 0.26 | 1.25 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_mean 6728118.00 | 0.20 | 0.92 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_std 6728118.00 | 0.07 | 0.44 | 0.00 | 0.00 | 0.00 | 0.00 | 13.44 | . item_cnt_shifted1 6728118.00 | 0.16 | 0.88 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_shifted2 6728118.00 | 0.14 | 0.85 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_shifted3 6728118.00 | 0.13 | 0.82 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_trend 6728118.00 | -0.06 | 0.44 | -12.50 | 0.00 | 0.00 | 0.00 | 5.00 | . &#51104;&#44624; &#51200;&#51109;&#54616;&#44592; . 여기까지 하고 데이터를 잠시 저장하겠습니다.(여기서부터 다시 실험해볼 수 있어요.) . . train_monthly = pd.read_csv(path + &#39;train_monthly.csv&#39;) . Train/Validation split . test set는 미래의 데이터입니다. 그러므로 같은 분포에서 시뮬레이션 되게끔 train/validation set을 나눌 필요가 있습니다. | train set은 3~28 까지의 date_block(달)이 될 것입니다. validation은 마지막 5 date block(29~32)로 하겠습니다. 그리고 test date block은 33이 됩니다. | 처음 3개월은 드롭합니다. 이미 window feature를 만드는데 사용되어서 이 기간동안의 windowed features는 유용하지 않습니다. | . train_set = train_monthly.query(&#39;date_block_num &gt;= 3 and date_block_num &lt; 28&#39;) validation_set = train_monthly.query(&#39;date_block_num &gt;=28 and date_block_num &lt; 33&#39;) test_set = train_monthly.query(&#39;date_block_num == 33&#39;).copy() train_set.dropna(subset=[&#39;item_cnt_month&#39;], inplace=True) validation_set.dropna(subset=[&#39;item_cnt_month&#39;], inplace=True) train_set.dropna(inplace=True) validation_set.dropna(inplace=True) # 이렇게 다 dropna할거면 한꺼번에 해도 되지 않나 싶긴하다.. 그래도 뜻이 명확하니 좋다. print(&#39;Train set records : &#39;, train_set.shape[0]) print(&#39;Validation set records : &#39;, validation_set.shape[0]) print(&#39;Test set records : &#39;, test_set.shape[0]) print(&#39;Train set records: %s (%.f%% of complete data)&#39; % (train_set.shape[0], ((train_set.shape[0]/train_monthly.shape[0])*100))) print(&#39;Validation set records: %s (%.f%% of complete data)&#39; % (validation_set.shape[0], ((validation_set.shape[0]/train_monthly.shape[0])*100))) . . Train set records : 4946785 Validation set records : 989412 Test set records : 197879 Train set records: 4946785 (74% of complete data) Validation set records: 989412 (15% of complete data) . Mean encoding . train/validation split 이후에 처리해야 하는 과정입니다. . gp_shop_mean = train_set.groupby([&#39;shop_id&#39;]).agg({&#39;item_cnt_month&#39; : [&#39;mean&#39;]}) gp_shop_mean.columns = [&#39;shop_mean&#39;] gp_shop_mean.reset_index(inplace=True) # Item mean encoding gp_item_mean = train_set.groupby([&#39;item_id&#39;]).agg({&#39;item_cnt_month&#39; : [&#39;mean&#39;]}) gp_item_mean.columns = [&#39;item_mean&#39;] gp_item_mean.reset_index(inplace=True) # Shop with item mean encoding gp_shop_item_mean = train_set.groupby([&#39;shop_id&#39;, &#39;item_id&#39;]).agg({&#39;item_cnt_month&#39; : [&#39;mean&#39;]}) gp_shop_item_mean.columns = [&#39;shop_item_mean&#39;] gp_shop_item_mean.reset_index(inplace=True) # Year mean encoding gp_year_mean = train_set.groupby([&#39;year&#39;]).agg({&#39;item_cnt_month&#39; : [&#39;mean&#39;]}) gp_year_mean.columns = [&#39;year_mean&#39;] gp_year_mean.reset_index(inplace=True) # Month mean encoding gp_month_mean = train_set.groupby([&#39;month&#39;]).agg({&#39;item_cnt_month&#39; : [&#39;mean&#39;]}) gp_month_mean.columns = [&#39;month_mean&#39;] gp_month_mean.reset_index(inplace=True) # Add meand encoding features to train set. train_set = pd.merge(train_set, gp_shop_mean, how=&#39;left&#39;, on=[&#39;shop_id&#39;]) train_set = pd.merge(train_set, gp_item_mean, how=&#39;left&#39;, on=[&#39;item_id&#39;]) train_set = pd.merge(train_set, gp_shop_item_mean, how=&#39;left&#39;, on=[&#39;shop_id&#39;, &#39;item_id&#39;]) train_set = pd.merge(train_set, gp_year_mean, how=&#39;left&#39;, on=[&#39;year&#39;]) train_set = pd.merge(train_set, gp_month_mean, how=&#39;left&#39;, on=[&#39;month&#39;]) # Add meand encoding features to validation set. validation_set = pd.merge(validation_set, gp_shop_mean, how=&#39;left&#39;, on=[&#39;shop_id&#39;]) validation_set = pd.merge(validation_set, gp_item_mean, how=&#39;left&#39;, on=[&#39;item_id&#39;]) validation_set = pd.merge(validation_set, gp_shop_item_mean, how=&#39;left&#39;, on=[&#39;shop_id&#39;, &#39;item_id&#39;]) validation_set = pd.merge(validation_set, gp_year_mean, how=&#39;left&#39;, on=[&#39;year&#39;]) validation_set = pd.merge(validation_set, gp_month_mean, how=&#39;left&#39;, on=[&#39;month&#39;]) . X_train = train_set.drop([&#39;item_cnt_month&#39;, &#39;date_block_num&#39;], axis=1) Y_train = train_set[&#39;item_cnt_month&#39;].astype(int) X_validation = validation_set.drop([&#39;item_cnt_month&#39;, &#39;date_block_num&#39;], axis=1) Y_validation = validation_set[&#39;item_cnt_month&#39;].astype(int) . int_features = [&#39;shop_id&#39;, &#39;item_id&#39;, &#39;year&#39;, &#39;month&#39;] X_train[int_features] = X_train[int_features].astype(&#39;int32&#39;) X_validation[int_features] = X_validation[int_features].astype(&#39;int32&#39;) . Build test set . 우리는 &#39;date_block_num&#39; 34에 대한 예측을 하려 합니다.그렇기에 우리의 test set은 block 33이고 예측은 block 34에 대한 예측이 됩니다. 즉, 우리는 block 33을 34번쨰 block을 예측하기 위해 써야합니다. . latests_records = pd.concat([train_set, validation_set]).drop_duplicates(subset=[&#39;shop_id&#39;, &#39;item_id&#39;], keep=&#39;last&#39;) X_test = pd.merge(test, latests_records, how=&#39;left&#39;, on=[&#39;shop_id&#39;, &#39;item_id&#39;], suffixes=[&#39;&#39;, &#39;_&#39;]) X_test[&#39;year&#39;] = 2015 X_test[&#39;month&#39;] = 9 X_test.drop(&#39;item_cnt_month&#39;, axis=1, inplace=True) X_test[int_features] = X_test[int_features].astype(&#39;int32&#39;) X_test = X_test[X_train.columns] . X_test . Unnamed: 0 shop_id item_id item_category_id item_price mean_item_price item_cnt mean_item_cnt transactions year month item_price_unit hist_min_item_price hist_max_item_price price_increase price_decrease item_cnt_min item_cnt_max item_cnt_mean item_cnt_std item_cnt_shifted1 item_cnt_shifted2 item_cnt_shifted3 item_trend shop_mean item_mean shop_item_mean year_mean month_mean . 0 6490255.00 | 5 | 5037 | 19.00 | 749.50 | 749.50 | 1.00 | 1.00 | 1.00 | 2015 | 9 | 749.00 | 0.00 | 25990.00 | 749.50 | 25240.50 | 1.00 | 3.00 | 1.67 | 1.15 | 3.00 | 1.00 | 1.00 | -1.00 | 0.13 | 0.70 | 0.28 | 0.22 | 0.17 | . 1 nan | 5 | 5320 | nan | nan | nan | nan | nan | nan | 2015 | 9 | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | . 2 6491376.00 | 5 | 5233 | 19.00 | 2997.00 | 999.00 | 3.00 | 1.00 | 3.00 | 2015 | 9 | 999.00 | 0.00 | 7191.75 | 2997.00 | 4194.75 | 1.00 | 3.00 | 2.00 | 1.00 | 1.00 | 2.00 | 3.00 | -0.75 | 0.13 | 0.07 | 0.12 | 0.22 | 0.17 | . 3 6491871.00 | 5 | 5232 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | 0.00 | 0.00 | 4796.00 | 0.00 | 4796.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.13 | 0.00 | 0.00 | 0.22 | 0.17 | . 4 nan | 5 | 5268 | nan | nan | nan | nan | nan | nan | 2015 | 9 | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | nan | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 214195 6453087.00 | 45 | 18454 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | 0.00 | 0.00 | 2189.00 | 0.00 | 2189.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.12 | 0.40 | 0.32 | 0.22 | 0.17 | . 214196 6454424.00 | 45 | 16188 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | 0.00 | 0.00 | 1359.00 | 0.00 | 1359.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.12 | 0.00 | 0.00 | 0.22 | 0.17 | . 214197 6450315.00 | 45 | 15757 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | 0.00 | 0.00 | 796.00 | 0.00 | 796.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.12 | 0.23 | 0.24 | 0.22 | 0.17 | . 214198 6453171.00 | 45 | 19648 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | 0.00 | 0.00 | 297.00 | 0.00 | 297.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.12 | 0.03 | 0.00 | 0.22 | 0.17 | . 214199 6452245.00 | 45 | 969 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 2015 | 9 | 0.00 | 0.00 | 5490.00 | 0.00 | 5490.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.12 | 0.20 | 0.20 | 0.22 | 0.17 | . 214200 rows × 29 columns . sets = [X_train, X_validation, X_test] # This was taking too long. # Replace missing values with the median of each item. # for dataset in sets: # for item_id in dataset[&#39;item_id&#39;].unique(): # for column in dataset.columns: # item_median = dataset[(dataset[&#39;item_id&#39;] == item_id)][column].median() # dataset.loc[(dataset[column].isnull()) &amp; (dataset[&#39;item_id&#39;] == item_id), column] = item_median # Replace missing values with the median of each shop. for dataset in sets: for shop_id in dataset[&#39;shop_id&#39;].unique(): for column in dataset.columns: shop_median = dataset[(dataset[&#39;shop_id&#39;] == shop_id)][column].median() dataset.loc[(dataset[column].isnull()) &amp; (dataset[&#39;shop_id&#39;] == shop_id), column] = shop_median # Fill remaining missing values on test set with mean. X_test.fillna(X_test.mean(), inplace=True) . test set에는 &#39;item_category_id&#39; 컬럼이 없습니다. 그렇다고 만들기는 까다로우니 드롭하겠습니다. . X_train.drop([&#39;item_category_id&#39;], axis=1, inplace=True) X_validation.drop([&#39;item_category_id&#39;], axis=1, inplace=True) X_test.drop([&#39;item_category_id&#39;], axis=1, inplace=True) . X_test.head().T . 0 1 2 3 4 . Unnamed: 0 6490255.00 | 6490184.50 | 6491376.00 | 6491871.00 | 6490184.50 | . shop_id 5.00 | 5.00 | 5.00 | 5.00 | 5.00 | . item_id 5037.00 | 5320.00 | 5233.00 | 5232.00 | 5268.00 | . item_price 749.50 | 0.00 | 2997.00 | 0.00 | 0.00 | . mean_item_price 749.50 | 0.00 | 999.00 | 0.00 | 0.00 | . item_cnt 1.00 | 0.00 | 3.00 | 0.00 | 0.00 | . mean_item_cnt 1.00 | 0.00 | 1.00 | 0.00 | 0.00 | . transactions 1.00 | 0.00 | 3.00 | 0.00 | 0.00 | . year 2015.00 | 2015.00 | 2015.00 | 2015.00 | 2015.00 | . month 9.00 | 9.00 | 9.00 | 9.00 | 9.00 | . item_price_unit 749.00 | 0.00 | 999.00 | 0.00 | 0.00 | . hist_min_item_price 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . hist_max_item_price 25990.00 | 2428.81 | 7191.75 | 4796.00 | 2428.81 | . price_increase 749.50 | 0.00 | 2997.00 | 0.00 | 0.00 | . price_decrease 25240.50 | 2394.00 | 4194.75 | 4796.00 | 2394.00 | . item_cnt_min 1.00 | 0.00 | 1.00 | 0.00 | 0.00 | . item_cnt_max 3.00 | 0.00 | 3.00 | 0.00 | 0.00 | . item_cnt_mean 1.67 | 0.00 | 2.00 | 0.00 | 0.00 | . item_cnt_std 1.15 | 0.00 | 1.00 | 0.00 | 0.00 | . item_cnt_shifted1 3.00 | 0.00 | 1.00 | 0.00 | 0.00 | . item_cnt_shifted2 1.00 | 0.00 | 2.00 | 0.00 | 0.00 | . item_cnt_shifted3 1.00 | 0.00 | 3.00 | 0.00 | 0.00 | . item_trend -1.00 | 0.00 | -0.75 | 0.00 | 0.00 | . shop_mean 0.13 | 0.13 | 0.13 | 0.13 | 0.13 | . item_mean 0.70 | 0.05 | 0.07 | 0.00 | 0.05 | . shop_item_mean 0.28 | 0.00 | 0.12 | 0.00 | 0.00 | . year_mean 0.22 | 0.22 | 0.22 | 0.22 | 0.22 | . month_mean 0.17 | 0.17 | 0.17 | 0.17 | 0.17 | . X_test.describe().T . count mean std min 25% 50% 75% max . Unnamed: 0 214200.00 | 6430389.42 | 78049.11 | 651488.00 | 6381778.75 | 6431162.50 | 6480756.00 | 6530238.00 | . shop_id 214200.00 | 31.64 | 17.56 | 2.00 | 16.00 | 34.50 | 47.00 | 59.00 | . item_id 214200.00 | 11019.40 | 6252.64 | 30.00 | 5381.50 | 11203.00 | 16071.50 | 22167.00 | . item_price 214200.00 | 239.96 | 1852.61 | 0.00 | 0.00 | 0.00 | 0.00 | 166944.50 | . mean_item_price 214200.00 | 133.81 | 865.99 | 0.00 | 0.00 | 0.00 | 0.00 | 32990.00 | . item_cnt 214200.00 | 0.23 | 0.95 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . mean_item_cnt 214200.00 | 0.13 | 0.37 | 0.00 | 0.00 | 0.00 | 0.00 | 10.00 | . transactions 214200.00 | 0.20 | 0.73 | 0.00 | 0.00 | 0.00 | 0.00 | 15.00 | . year 214200.00 | 2015.00 | 0.00 | 2015.00 | 2015.00 | 2015.00 | 2015.00 | 2015.00 | . month 214200.00 | 9.00 | 0.00 | 9.00 | 9.00 | 9.00 | 9.00 | 9.00 | . item_price_unit 214200.00 | inf | nan | 0.00 | 0.00 | 0.00 | 0.00 | inf | . hist_min_item_price 214200.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | 0.00 | . hist_max_item_price 214200.00 | 5396.39 | 11365.76 | 0.00 | 1194.00 | 2428.81 | 5196.00 | 366860.00 | . price_increase 214200.00 | 239.96 | 1852.61 | 0.00 | 0.00 | 0.00 | 0.00 | 166944.50 | . price_decrease 214200.00 | 5151.84 | 10778.85 | 0.00 | 1098.00 | 2394.00 | 5063.00 | 366860.00 | . item_cnt_min 214200.00 | 0.18 | 0.74 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_max 214200.00 | 0.33 | 1.27 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_mean 214200.00 | 0.25 | 0.95 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_std 214200.00 | 0.08 | 0.43 | 0.00 | 0.00 | 0.00 | 0.00 | 12.02 | . item_cnt_shifted1 214200.00 | 0.21 | 0.91 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_shifted2 214200.00 | 0.18 | 0.83 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_cnt_shifted3 214200.00 | 0.17 | 0.85 | 0.00 | 0.00 | 0.00 | 0.00 | 20.00 | . item_trend 214200.00 | -0.08 | 0.46 | -11.00 | 0.00 | 0.00 | 0.00 | 5.00 | . shop_mean 214200.00 | 0.19 | 0.13 | 0.00 | 0.12 | 0.17 | 0.20 | 0.68 | . item_mean 214200.00 | 0.18 | 0.41 | 0.00 | 0.01 | 0.05 | 0.18 | 6.97 | . shop_item_mean 214200.00 | 0.18 | 0.56 | 0.00 | 0.00 | 0.00 | 0.12 | 20.00 | . year_mean 214200.00 | 0.22 | 0.00 | 0.14 | 0.22 | 0.22 | 0.22 | 0.22 | . month_mean 214200.00 | 0.17 | 0.00 | 0.14 | 0.17 | 0.17 | 0.17 | 0.21 | . Modeling the data . Tree based models . int_features = [&#39;shop_id&#39;, &#39;item_id&#39;, &#39;year&#39;, &#39;month&#39;] X_train[int_features] = X_train[int_features].astype(&#39;int32&#39;) X_validation[int_features] = X_validation[int_features].astype(&#39;int32&#39;) . # pandas.Categorical 자료형을 사용하면 데이터 세트의 사전 처리속도를 200배 개선할 수 있다고 합니다. X_train[int_features] = X_train[int_features].astype(&#39;category&#39;) X_validation[int_features] = X_validation[int_features].astype(&#39;category&#39;) X_test[int_features] = X_test[int_features].astype(&#39;category&#39;) . def model_performance_sc_plot(predictions, labels, title): # Get min and max values of the predictions and labels. min_val = max(max(predictions), max(labels)) max_val = min(min(predictions), min(labels)) # Create dataframe with predicitons and labels. performance_df = pd.DataFrame({&quot;Label&quot;:labels}) performance_df[&quot;Prediction&quot;] = predictions # Plot data sns.jointplot(y=&quot;Label&quot;, x=&quot;Prediction&quot;, data=performance_df, kind=&quot;reg&quot;, height=7) plt.plot([min_val, max_val], [min_val, max_val], &#39;m--&#39;) plt.title(title, fontsize=9) plt.show() . XGBoost . xgb_features = [&#39;item_cnt&#39;,&#39;item_cnt_mean&#39;, &#39;item_cnt_std&#39;, &#39;item_cnt_shifted1&#39;, &#39;item_cnt_shifted2&#39;, &#39;item_cnt_shifted3&#39;, &#39;shop_mean&#39;, &#39;shop_item_mean&#39;, &#39;item_trend&#39;, &#39;mean_item_cnt&#39;] xgb_train = X_train[xgb_features] xgb_val = X_validation[xgb_features] xgb_test = X_test[xgb_features] . xgb_model = XGBRegressor(max_depth=8, n_estimators=500, min_child_weight=1000, colsample_bytree=0.7, subsample=0.7, eta=0.3, seed=0) xgb_model.fit(xgb_train, Y_train, eval_metric=&quot;rmse&quot;, eval_set=[(xgb_train, Y_train), (xgb_val, Y_validation)], verbose=20, early_stopping_rounds=20) . [08:43:19] WARNING: /workspace/src/objective/regression_obj.cu:152: reg:linear is now deprecated in favor of reg:squarederror. [08:43:20] WARNING: /workspace/src/learner.cc:686: Tree method is automatically selected to be &#39;approx&#39; for faster speed. To use old behavior (exact greedy algorithm on single machine), set tree_method to &#39;exact&#39;. [0] validation_0-rmse:0.942842 validation_1-rmse:0.92285 Multiple eval metrics have been passed: &#39;validation_1-rmse&#39; will be used for early stopping. Will train until validation_1-rmse hasn&#39;t improved in 20 rounds. [20] validation_0-rmse:0.684505 validation_1-rmse:0.790798 Stopping. Best iteration: [18] validation_0-rmse:0.687606 validation_1-rmse:0.788279 . XGBRegressor(base_score=0.5, booster=&#39;gbtree&#39;, colsample_bylevel=1, colsample_bynode=1, colsample_bytree=0.7, eta=0.3, gamma=0, importance_type=&#39;gain&#39;, learning_rate=0.1, max_delta_step=0, max_depth=8, min_child_weight=1000, missing=None, n_estimators=500, n_jobs=1, nthread=None, objective=&#39;reg:linear&#39;, random_state=0, reg_alpha=0, reg_lambda=1, scale_pos_weight=1, seed=0, silent=None, subsample=0.7, verbosity=1) . plt.rcParams[&quot;figure.figsize&quot;] = (15, 6) plot_importance(xgb_model) plt.show() . xgb_train_pred = xgb_model.predict(xgb_train) xgb_val_pred = xgb_model.predict(xgb_val) xgb_test_pred = xgb_model.predict(xgb_test) . print(&#39;Train rmse:&#39;, np.sqrt(mean_squared_error(Y_train, xgb_train_pred))) print(&#39;Validation rmse:&#39;, np.sqrt(mean_squared_error(Y_validation, xgb_val_pred))) . Train rmse: 0.6921620336737511 Validation rmse: 0.7898067075909768 . Random forest . rf_features = [&#39;shop_id&#39;, &#39;item_id&#39;, &#39;item_cnt&#39;, &#39;transactions&#39;, &#39;year&#39;, &#39;item_cnt_mean&#39;, &#39;item_cnt_std&#39;, &#39;item_cnt_shifted1&#39;, &#39;shop_mean&#39;, &#39;item_mean&#39;, &#39;item_trend&#39;, &#39;mean_item_cnt&#39;] rf_train = X_train[rf_features] rf_val = X_validation[rf_features] rf_test = X_test[rf_features] . rf_model = RandomForestRegressor(n_estimators=50, max_depth=7, random_state=0, n_jobs=-1) rf_model.fit(rf_train, Y_train) . RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=7, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=50, n_jobs=-1, oob_score=False, random_state=0, verbose=0, warm_start=False) . rf_train_pred = rf_model.predict(rf_train) rf_val_pred = rf_model.predict(rf_val) rf_test_pred = rf_model.predict(rf_test) . print(&#39;Train rmse:&#39;, np.sqrt(mean_squared_error(Y_train, rf_train_pred))) print(&#39;Validation rmse:&#39;, np.sqrt(mean_squared_error(Y_validation, rf_val_pred))) . Train rmse: 0.6985868322226099 Validation rmse: 0.776123635046122 . Linear models . lr_features = [&#39;item_cnt&#39;, &#39;item_cnt_shifted1&#39;, &#39;item_trend&#39;, &#39;mean_item_cnt&#39;, &#39;shop_mean&#39;] lr_train = X_train[lr_features] lr_val = X_validation[lr_features] lr_test = X_test[lr_features] . lr_scaler = MinMaxScaler() lr_scaler.fit(lr_train) lr_train = lr_scaler.transform(lr_train) lr_val = lr_scaler.transform(lr_val) lr_test = lr_scaler.transform(lr_test) . lr_model = LinearRegression(n_jobs=-1) lr_model.fit(lr_train, Y_train) . LinearRegression(copy_X=True, fit_intercept=True, n_jobs=-1, normalize=False) . lr_train_pred = lr_model.predict(lr_train) lr_val_pred = lr_model.predict(lr_val) lr_test_pred = lr_model.predict(lr_test) . print(&#39;Train rmse:&#39;, np.sqrt(mean_squared_error(Y_train, lr_train_pred))) print(&#39;Validation rmse:&#39;, np.sqrt(mean_squared_error(Y_validation, lr_val_pred))) . Train rmse: 0.7347132326333323 Validation rmse: 0.7755311093536288 . KNN Regressor . knn_features = [&#39;item_cnt&#39;, &#39;item_cnt_mean&#39;, &#39;item_cnt_std&#39;, &#39;item_cnt_shifted1&#39;, &#39;item_cnt_shifted2&#39;, &#39;shop_mean&#39;, &#39;shop_item_mean&#39;, &#39;item_trend&#39;, &#39;mean_item_cnt&#39;] # Subsample train set (using the whole data was taking too long). X_train_sampled = X_train[:100000] Y_train_sampled = Y_train[:100000] knn_train = X_train_sampled[knn_features] knn_val = X_validation[knn_features] knn_test = X_test[knn_features] . knn_scaler = MinMaxScaler() knn_scaler.fit(knn_train) knn_train = knn_scaler.transform(knn_train) knn_val = knn_scaler.transform(knn_val) knn_test = knn_scaler.transform(knn_test) . knn_model = KNeighborsRegressor(n_neighbors=9, leaf_size=13, n_jobs=-1) knn_model.fit(knn_train, Y_train_sampled) . KNeighborsRegressor(algorithm=&#39;auto&#39;, leaf_size=13, metric=&#39;minkowski&#39;, metric_params=None, n_jobs=-1, n_neighbors=9, p=2, weights=&#39;uniform&#39;) . knn_train_pred = knn_model.predict(knn_train) knn_val_pred = knn_model.predict(knn_val) knn_test_pred = knn_model.predict(knn_test) . print(&#39;Train rmse:&#39;, np.sqrt(mean_squared_error(Y_train_sampled, knn_train_pred))) print(&#39;Validation rmse:&#39;, np.sqrt(mean_squared_error(Y_validation, knn_val_pred))) . Train rmse: 0.48661554779725724 Validation rmse: 0.8003593727057509 . Create new datasets with the predictions from first level . 메타 모델 학습을 위해 1차 모델들의 예측값을 갖는 데이터 프레임을 만들겠습니다. 이 데이터 프레임은 X_validation을 1차 모델로 예측한 값들로 구성됩니다. . first_level = pd.DataFrame(xgb_val_pred, columns=[&#39;xgbm&#39;]) first_level[&#39;random_forest&#39;] = rf_val_pred first_level[&#39;linear_regression&#39;] = lr_val_pred first_level[&#39;knn&#39;] = knn_val_pred first_level[&#39;label&#39;] = Y_validation.values first_level.head(20) . xgbm random_forest linear_regression knn label . 0 0.70 | 0.62 | 0.60 | 1.00 | 0 | . 1 0.64 | 0.56 | 0.04 | 0.78 | 0 | . 2 0.10 | 0.21 | 0.04 | 0.00 | 0 | . 3 0.81 | 0.95 | 0.04 | 0.11 | 4 | . 4 1.59 | 1.57 | 1.46 | 0.67 | 1 | . 5 0.64 | 0.46 | 0.04 | 0.11 | 1 | . 6 0.43 | 0.21 | 0.04 | 0.11 | 0 | . 7 0.10 | 0.06 | 0.04 | 0.00 | 1 | . 8 0.38 | 0.21 | 0.04 | 0.11 | 0 | . 9 1.73 | 1.13 | 1.15 | 2.89 | 2 | . 10 0.53 | 0.27 | 0.04 | 0.56 | 0 | . 11 0.43 | 0.41 | 0.04 | 0.11 | 0 | . 12 0.64 | 0.67 | 0.04 | 0.11 | 0 | . 13 0.53 | 0.46 | 0.04 | 0.33 | 0 | . 14 0.13 | 0.06 | 0.04 | 0.00 | 0 | . 15 0.46 | 0.28 | 0.04 | 0.22 | 1 | . 16 0.28 | 0.20 | 0.04 | 0.11 | 0 | . 17 0.53 | 0.28 | 0.04 | 0.11 | 0 | . 18 0.57 | 0.57 | 0.60 | 0.89 | 0 | . 19 0.52 | 0.60 | 1.08 | 0.33 | 0 | . 이 데이터 프레임은 X_test를 1차 모델로 예측한 값들로 구성됩니다. . first_level_test = pd.DataFrame(xgb_test_pred, columns=[&#39;xgbm&#39;]) first_level_test[&#39;random_forest&#39;] = rf_test_pred first_level_test[&#39;linear_regression&#39;] = lr_test_pred first_level_test[&#39;knn&#39;] = knn_test_pred first_level_test.head() . xgbm random_forest linear_regression knn . 0 0.41 | 0.95 | 0.85 | 0.89 | . 1 0.08 | 0.06 | 0.06 | 0.00 | . 2 0.52 | 0.85 | 1.79 | 1.11 | . 3 0.08 | 0.00 | 0.06 | 0.00 | . 4 0.08 | 0.06 | 0.06 | 0.00 | . 메타모델은 LinearRegression으로 합니다. 메타모델의 절편 값이 0이고 모든 기울기 값이 동일할 때 이 앙상블 방법은 평균과 동일합니다. . meta_model = LinearRegression(n_jobs=-1) . first_level.drop(&#39;label&#39;, axis=1, inplace=True) meta_model.fit(first_level, Y_validation) . LinearRegression(copy_X=True, fit_intercept=True, n_jobs=-1, normalize=False) . ensemble_pred = meta_model.predict(first_level) final_predictions = meta_model.predict(first_level_test) . print(&#39;Train rmse:&#39;, np.sqrt(mean_squared_error(ensemble_pred, Y_validation))) . Train rmse: 0.7649936729638841 . prediction_df = pd.DataFrame(test[&#39;ID&#39;], columns=[&#39;ID&#39;]) prediction_df[&#39;item_cnt_month&#39;] = final_predictions.clip(0., 20.) prediction_df.to_csv(path + &#39;submission.csv&#39;, index=False) prediction_df.head(10) . ID item_cnt_month . 0 0 | 0.82 | . 1 1 | 0.08 | . 2 2 | 1.27 | . 3 3 | 0.06 | . 4 4 | 0.08 | . 5 5 | 0.94 | . 6 6 | 1.24 | . 7 7 | 0.21 | . 8 8 | 1.99 | . 9 9 | 0.06 | .",
            "url": "https://edypidy.github.io/studyblog/kaggle/jupyter/meta-model/time-series/xgboost/randomforest/linearregression/knn/2021/10/25/kaggle_study-_Predict_Future_Sales.html",
            "relUrl": "/kaggle/jupyter/meta-model/time-series/xgboost/randomforest/linearregression/knn/2021/10/25/kaggle_study-_Predict_Future_Sales.html",
            "date": " • Oct 25, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "[Colab] 코랩 plot 한국어 깨짐 현상 해결",
            "content": "Intro . 코랩의 matplotlib에선 plot의 한글이 깨지는 현상이 있습니다. 가끔은 한글 타이틀이나 ticks를 설정해야 할 때는 정말 불편한데요. . 이번 포스팅에선 코랩의 한글이 깨지는 현상을 해결하는 방법을 알아보겠습니다. 방법은 아주 간단합니다. 2가지 단계를 차례로 진행하시면 됩니다. . 1&#45800;&#44228; : &#45208;&#45588; &#54256;&#53944; &#49444;&#52824;&#54980; &#49892;&#54665; . 나눔 폰트를 설치해줍니다. . !sudo apt-get install -y fonts-nanum !sudo fc-cache -fv !rm ~/.cache/matplotlib -rf . Reading package lists... Done Building dependency tree Reading state information... Done The following NEW packages will be installed: fonts-nanum 0 upgraded, 1 newly installed, 0 to remove and 37 not upgraded. Need to get 9,604 kB of archives. After this operation, 29.5 MB of additional disk space will be used. Get:1 http://archive.ubuntu.com/ubuntu bionic/universe amd64 fonts-nanum all 20170925-1 [9,604 kB] Fetched 9,604 kB in 1s (6,566 kB/s) debconf: unable to initialize frontend: Dialog debconf: (No usable dialog-like program is installed, so the dialog based frontend cannot be used. at /usr/share/perl5/Debconf/FrontEnd/Dialog.pm line 76, &lt;&gt; line 1.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Selecting previously unselected package fonts-nanum. (Reading database ... 155222 files and directories currently installed.) Preparing to unpack .../fonts-nanum_20170925-1_all.deb ... Unpacking fonts-nanum (20170925-1) ... Setting up fonts-nanum (20170925-1) ... Processing triggers for fontconfig (2.12.6-0ubuntu2) ... /usr/share/fonts: caching, new cache contents: 0 fonts, 1 dirs /usr/share/fonts/truetype: caching, new cache contents: 0 fonts, 3 dirs /usr/share/fonts/truetype/humor-sans: caching, new cache contents: 1 fonts, 0 dirs /usr/share/fonts/truetype/liberation: caching, new cache contents: 16 fonts, 0 dirs /usr/share/fonts/truetype/nanum: caching, new cache contents: 10 fonts, 0 dirs /usr/local/share/fonts: caching, new cache contents: 0 fonts, 0 dirs /root/.local/share/fonts: skipping, no such directory /root/.fonts: skipping, no such directory /var/cache/fontconfig: cleaning cache directory /root/.cache/fontconfig: not cleaning non-existent cache directory /root/.fontconfig: not cleaning non-existent cache directory fc-cache: succeeded . 이후 아래의 코드를 실행해보면 실망스러운 결과가 나옵니다. . import matplotlib.pyplot as plt import matplotlib.font_manager as fm plt.rc(&#39;font&#39;, family=&#39;NanumBarunGothic&#39;) plt.plot() plt.title(&#39;한국어&#39;) plt.show() . findfont: Font family [&#39;NanumBarunGothic&#39;] not found. Falling back to DejaVu Sans. /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:214: RuntimeWarning: Glyph 54620 missing from current font. font.set_text(s, 0.0, flags=flags) /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:214: RuntimeWarning: Glyph 44397 missing from current font. font.set_text(s, 0.0, flags=flags) /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:214: RuntimeWarning: Glyph 50612 missing from current font. font.set_text(s, 0.0, flags=flags) findfont: Font family [&#39;NanumBarunGothic&#39;] not found. Falling back to DejaVu Sans. /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:183: RuntimeWarning: Glyph 54620 missing from current font. font.set_text(s, 0, flags=flags) /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:183: RuntimeWarning: Glyph 44397 missing from current font. font.set_text(s, 0, flags=flags) /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:183: RuntimeWarning: Glyph 50612 missing from current font. font.set_text(s, 0, flags=flags) . 2&#45800;&#44228; : &#47088;&#53440;&#51076; &#45796;&#49884;&#49892;&#54665; &#54980; &#49892;&#54665; . 여기서 포기하지 않고 런타일 다시실행을 눌러줍니다. . import matplotlib.pyplot as plt import matplotlib.font_manager as fm plt.rc(&#39;font&#39;, family=&#39;NanumBarunGothic&#39;) plt.plot() plt.title(&#39;한국어&#39;) plt.show() . /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:214: RuntimeWarning: Glyph 8722 missing from current font. font.set_text(s, 0.0, flags=flags) /usr/local/lib/python3.7/dist-packages/matplotlib/backends/backend_agg.py:183: RuntimeWarning: Glyph 8722 missing from current font. font.set_text(s, 0, flags=flags) . warning 메세지가 보기 불편하다면 아래의 코드를 실행해줍니다. . import warnings; warnings.filterwarnings(&#39;ignore&#39;) . plt.plot() plt.title(&#39;한국어&#39;) plt.show() . 너무나 간단히 해결되었습니다. :) .",
            "url": "https://edypidy.github.io/studyblog/code/colab/%ED%95%9C%EA%B5%AD%EC%96%B4/%ED%95%9C%EA%B5%AD%EC%96%B4%20%EA%B9%A8%EC%A7%90/matplotlib/font_manager/2021/10/08/%EC%BD%94%EB%9E%A9_plot_%ED%95%9C%EA%B8%80_%EA%B9%A8%EC%A7%90_%ED%95%B4%EA%B2%B0.html",
            "relUrl": "/code/colab/%ED%95%9C%EA%B5%AD%EC%96%B4/%ED%95%9C%EA%B5%AD%EC%96%B4%20%EA%B9%A8%EC%A7%90/matplotlib/font_manager/2021/10/08/%EC%BD%94%EB%9E%A9_plot_%ED%95%9C%EA%B8%80_%EA%B9%A8%EC%A7%90_%ED%95%B4%EA%B2%B0.html",
            "date": " • Oct 8, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "[Code] 네이버 금융 api를 이용한 금융데이터 크롤링. ",
            "content": "아주 흔하디 흔한 네이버 금융 api를 이용한 금융 데이터 크롤링을 해보겠습니다. . import requests import json import pandas as pd . corp_code = &#39;000020&#39; startTime = 20160104 endTime = 20210730 timeframe = &#39;day&#39; url = f&#39;https://api.finance.naver.com/ siseJson.naver?symbol={corp_code}&amp; requestType=1&amp; startTime={startTime}&amp; endTime={endTime}&amp; timeframe={timeframe}&#39; result = requests.post(url) . url . &#39;https://api.finance.naver.com/siseJson.naver?symbol=000020&amp;requestType=1&amp;startTime=20160104&amp;endTime=20210730&amp;timeframe=day&#39; . 위의 url은 아래와 같습니다. 참고로 는 줄바꿈을 위해 쓴 것이니 . f&#39;https://api.finance.naver.com/siseJson.naver?symbol={corp_code}&amp;requestType=1&amp;startTime={startTime}&amp;endTime={endTime}&amp;timeframe={timeframe}&#39; . 와 같이 써도 됩니다. . result . &lt;Response [200]&gt; . response로 200을 받은 것을 보니 잘 받아온 것 같습니다. . result.text[:500] . &#39; n [[ &#39;날짜 &#39;, &#39;시가 &#39;, &#39;고가 &#39;, &#39;저가 &#39;, &#39;종가 &#39;, &#39;거래량 &#39;, &#39;외국인소진율 &#39;], n n t n t n t t n[&#34;20160104&#34;, 8130, 8150, 7920, 8140, 281440, 7.45], n t t n[&#34;20160105&#34;, 8040, 8250, 8000, 8190, 243179, 7.49], n t t n[&#34;20160106&#34;, 8200, 8590, 8110, 8550, 609906, 7.63], n t t n[&#34;20160107&#34;, 8470, 8690, 8190, 8380, 704752, 7.59], n t t n[&#34;20160108&#34;, 8210, 8900, 8130, 8770, 802330, 7.6], n t t n[&#34;20160111&#34;, 8870, 10100, 8800, 9380, 2844188, 7.25], n t t n[&#34;20160112&#34;, 9560, 9560, 8930, 9020, 834633, 7.05], n t t n[&#34;20160113&#34;, 9190, 9200, 8600, 8780, 885059, 6.89], n t t&#39; . result의 text 속성엔 위와 같이 요청한 데이터가 담겨서 옵니다. . replace 메소드와 strip메소드를 사용해서 아래와 같이 데이터를 정제해줍니다. . result.text.replace(&quot;&#39;&quot;,&#39;&quot;&#39;).strip()[:500] . &#39;[[&#34;날짜&#34;, &#34;시가&#34;, &#34;고가&#34;, &#34;저가&#34;, &#34;종가&#34;, &#34;거래량&#34;, &#34;외국인소진율&#34;], n n t n t n t t n[&#34;20160104&#34;, 8130, 8150, 7920, 8140, 281440, 7.45], n t t n[&#34;20160105&#34;, 8040, 8250, 8000, 8190, 243179, 7.49], n t t n[&#34;20160106&#34;, 8200, 8590, 8110, 8550, 609906, 7.63], n t t n[&#34;20160107&#34;, 8470, 8690, 8190, 8380, 704752, 7.59], n t t n[&#34;20160108&#34;, 8210, 8900, 8130, 8770, 802330, 7.6], n t t n[&#34;20160111&#34;, 8870, 10100, 8800, 9380, 2844188, 7.25], n t t n[&#34;20160112&#34;, 9560, 9560, 8930, 9020, 834633, 7.05], n t t n[&#34;20160113&#34;, 9190, 9200, 8600, 8780, 885059, 6.89], n t t n[&#39; . json의 loads 메소드를 사용해서 데이터 형태를 아래와 같이 바꿔줍니다. . json.loads(result.text.replace(&quot;&#39;&quot;,&#39;&quot;&#39;).strip())[:5] . [[&#39;날짜&#39;, &#39;시가&#39;, &#39;고가&#39;, &#39;저가&#39;, &#39;종가&#39;, &#39;거래량&#39;, &#39;외국인소진율&#39;], [&#39;20160104&#39;, 8130, 8150, 7920, 8140, 281440, 7.45], [&#39;20160105&#39;, 8040, 8250, 8000, 8190, 243179, 7.49], [&#39;20160106&#39;, 8200, 8590, 8110, 8550, 609906, 7.63], [&#39;20160107&#39;, 8470, 8690, 8190, 8380, 704752, 7.59]] . 여기서부턴 그냥 pandas 데이터 프레임 만드는 것과 동일합니다. 정리하면 코드는 아래와 같습니다. . import requests import json import pandas as pd corp_code = &#39;000020&#39; startTime = 20160104 endTime = 20210730 timeframe = &#39;day&#39; url = f&#39;https://api.finance.naver.com/ siseJson.naver?symbol={corp_code}&amp; requestType=1&amp; startTime={startTime}&amp; endTime={endTime}&amp; timeframe={timeframe}&#39; result = requests.post(url) data = result.text.replace(&quot;&#39;&quot;,&#39;&quot;&#39;).strip() data = json.loads(data) data = pd.DataFrame(data[1:], columns=data[0]) data[&#39;날짜&#39;] = pd.to_datetime(data[&#39;날짜&#39;]) data[&#39;종목코드&#39;] = corp_code . data . 날짜 시가 고가 저가 종가 거래량 외국인소진율 종목코드 . 0 2016-01-04 | 8130 | 8150 | 7920 | 8140 | 281440 | 7.45 | 000020 | . 1 2016-01-05 | 8040 | 8250 | 8000 | 8190 | 243179 | 7.49 | 000020 | . 2 2016-01-06 | 8200 | 8590 | 8110 | 8550 | 609906 | 7.63 | 000020 | . 3 2016-01-07 | 8470 | 8690 | 8190 | 8380 | 704752 | 7.59 | 000020 | . 4 2016-01-08 | 8210 | 8900 | 8130 | 8770 | 802330 | 7.60 | 000020 | . ... ... | ... | ... | ... | ... | ... | ... | ... | . 1367 2021-07-26 | 14700 | 14700 | 14350 | 14400 | 192180 | 2.54 | 000020 | . 1368 2021-07-27 | 14500 | 14550 | 14350 | 14400 | 96069 | 2.55 | 000020 | . 1369 2021-07-28 | 14300 | 14600 | 14300 | 14450 | 94912 | 2.56 | 000020 | . 1370 2021-07-29 | 14500 | 14650 | 14500 | 14600 | 83468 | 2.56 | 000020 | . 1371 2021-07-30 | 14650 | 14750 | 14400 | 14650 | 115604 | 2.55 | 000020 | . 1372 rows × 8 columns . &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot;viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot;&gt; &lt;/svg&gt; 셀레니움 라이브러리를 이용하는 것이 아니라 api를 이용해 크롤링을 한다면 네이버 금융 api 이외에도 데이터 api가 공개되어있는 사이트들을 크롤링 할 수 있습니다. .",
            "url": "https://edypidy.github.io/studyblog/code/%ED%81%AC%EB%A1%A4%EB%A7%81/api/%EB%84%A4%EC%9D%B4%EB%B2%84/%EB%84%A4%EC%9D%B4%EB%B2%84%20%EA%B8%88%EC%9C%B5/2021/09/30/%EB%84%A4%EC%9D%B4%EB%B2%84_%EA%B8%88%EC%9C%B5_api%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EA%B8%88%EC%9C%B5%EB%8D%B0%EC%9D%B4%ED%84%B0_%ED%81%AC%EB%A1%A4%EB%A7%81-(1).html",
            "relUrl": "/code/%ED%81%AC%EB%A1%A4%EB%A7%81/api/%EB%84%A4%EC%9D%B4%EB%B2%84/%EB%84%A4%EC%9D%B4%EB%B2%84%20%EA%B8%88%EC%9C%B5/2021/09/30/%EB%84%A4%EC%9D%B4%EB%B2%84_%EA%B8%88%EC%9C%B5_api%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EA%B8%88%EC%9C%B5%EB%8D%B0%EC%9D%B4%ED%84%B0_%ED%81%AC%EB%A1%A4%EB%A7%81-(1).html",
            "date": " • Sep 30, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "[SSUDA][Kaggle Review]Heart Desease 데이터 셋 분석과 train_test split에 따른 Accuracy",
            "content": ". Data copyright . 이번에 분석해볼 데이터는 캐글의 Heart Desease 데이터입니다. 출처는 아래와 같습니다. . https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset . Intro . 개인적으로 진행중인 kaggle review에서의 이번주차 데이터 셋입니다. 캐글 코드를 매우 많이 참고한 점을 밝힙니다. 참고한 코드 주소는 아래에 참고한 플랏에서 밝혀놓았습니다. . 아래의 바닐라 모델 중 Accuracy가 좋은 것을 튜닝으로 개선시켜 볼 것입니다. . XGboost, AdaBoost, Lgbm, Logistic Regression, RandomForest, MLPClassifier . Data description . Age : Age of the patient . | Sex : Sex of the patient . | exang: exercise induced angina (1 = yes; 0 = no) . | ca: number of major vessels (0-3) . | cp : Chest Pain type chest pain type . Value 1: typical angina Value 2: atypical angina Value 3: non-anginal pain Value 4: asymptomatic . | trtbps : resting blood pressure (in mm Hg) . | chol : cholestoral in mg/dl fetched via BMI sensor . | fbs : (fasting blood sugar &gt; 120 mg/dl) (1 = true; 0 = false) . | rest_ecg : resting electrocardiographic results . Value 0: normal Value 1: having ST-T wave abnormality (T wave inversions and/or ST elevation or depression of &gt; 0.05 mV) Value 2: showing probable or definite left ventricular hypertrophy by Estes&#39; criteria . | thalach : maximum heart rate achieved . | target : 0= less chance of heart attack 1= more chance of heart attack . | . Preparation . Libraries &amp; Workspace setting . import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline import warnings warnings.filterwarnings(&quot;ignore&quot;) import scipy.stats as ss sns.set_palette(&#39;deep&#39;) sns.set_color_codes() sns.set_style(&#39;white&#39;) . . Load Data . df = pd.read_csv(&#39;https://raw.githubusercontent.com/edypidy/Datasets/main/Heart%20Attack%20Analysis%20%26%20Prediction%20Dataset/heart.csv&#39;) df.head(3) . age sex cp trtbps chol fbs restecg thalachh exng oldpeak slp caa thall output . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . Train Test Split . 여러 모델에 적용하기 위해선 스케일 조정 작업이 필요해 보이고, 연속형, 명목형, 순서형 변수들의 구분이 필요하다. 순서형 변수의 경우 스케일을 맞추기 위해 one-hot encoding을 하는 것이 좋아 보인다. . Continuous : age, trtbps, chol, thalachh, oldpeak Cat_Ordered : cp, restecg, slp, caa, thall Cat_Nominal : sex, fbs, exng . continuous = [&#39;age&#39;, &#39;trtbps&#39;, &#39;chol&#39;, &#39;thalachh&#39;, &#39;oldpeak&#39;] cat_ordered = [&#39;cp&#39;, &#39;restecg&#39;, &#39;slp&#39;, &#39;caa&#39;, &#39;thall&#39;] cat_nominal = [&#39;sex&#39;, &#39;fbs&#39;, &#39;exng&#39;] categorical = cat_ordered + cat_nominal . . # train_test가 나눠져 있지 않다. 따로 빼두자.. full = pd.get_dummies(df, columns=categorical) . . train, test로 나눠져있는 것이 아닌 feature - target 이 모두 있는 데이터 셋이다. 모델의 최종 검증용 데이터가 따로 있는 것이 아니기 때문에 데이터를 split 해놓을 필요가 있다.(최대한 실전 문제처럼 해보자) . from sklearn.model_selection import train_test_split train, test = train_test_split(df, test_size=0.2, shuffle=True, random_state=42) train_full, test_full = train_test_split(full, test_size=0.2, shuffle=True, random_state=42) . stratify를 설정 해야할지 고민을 좀 했다. 하지만 실제 데이터 셋이라면 target(output)의 비율이 완전히 동일할리가 없다(분포는 비슷하겠지만). (default)shuffle=True 로 둔다. . print(&#39;train shape &amp; target ratio : &#39;, train.shape, train_full.shape, &#39;%.2f&#39;%train.output.mean()) print(&#39;test shape &amp; target ratio : &#39;, test.shape, test_full.shape, &#39;%.2f&#39;%test.output.mean()) . . train shape &amp; target ratio : (242, 14) (242, 31) 0.55 test shape &amp; target ratio : (61, 14) (61, 31) 0.52 . target의 비율이라도 잘 나눠졌는지 확인하고 시작하자. . EDA . Peek . Isna? . train.isna().apply(pd.value_counts) . . age sex cp trtbps chol fbs restecg thalachh exng oldpeak slp caa thall output . False 242 | 242 | 242 | 242 | 242 | 242 | 242 | 242 | 242 | 242 | 242 | 242 | 242 | 242 | . Missing value는 없다. . General Stats . train.describe() . . age sex cp trtbps chol fbs restecg thalachh exng oldpeak slp caa thall output . count 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | 242.000000 | . mean 54.462810 | 0.657025 | 0.991736 | 130.359504 | 246.842975 | 0.128099 | 0.553719 | 150.115702 | 0.314050 | 1.013223 | 1.421488 | 0.681818 | 2.301653 | 0.549587 | . std 9.204492 | 0.475687 | 1.022533 | 16.828858 | 52.795465 | 0.334893 | 0.530410 | 22.352398 | 0.465098 | 1.102577 | 0.607724 | 0.990620 | 0.593811 | 0.498566 | . min 29.000000 | 0.000000 | 0.000000 | 94.000000 | 131.000000 | 0.000000 | 0.000000 | 88.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | . 25% 48.000000 | 0.000000 | 0.000000 | 120.000000 | 212.000000 | 0.000000 | 0.000000 | 136.000000 | 0.000000 | 0.000000 | 1.000000 | 0.000000 | 2.000000 | 0.000000 | . 50% 55.500000 | 1.000000 | 1.000000 | 130.000000 | 239.500000 | 0.000000 | 1.000000 | 154.000000 | 0.000000 | 0.800000 | 1.000000 | 0.000000 | 2.000000 | 1.000000 | . 75% 61.000000 | 1.000000 | 2.000000 | 140.000000 | 274.750000 | 0.000000 | 1.000000 | 165.750000 | 1.000000 | 1.600000 | 2.000000 | 1.000000 | 3.000000 | 1.000000 | . max 77.000000 | 1.000000 | 3.000000 | 192.000000 | 564.000000 | 1.000000 | 2.000000 | 202.000000 | 1.000000 | 5.600000 | 2.000000 | 4.000000 | 3.000000 | 1.000000 | . Univariate Analysis . 캐글 탐색 중에 바이올린 차트를 너무 세련되게 그려놓은 분이 있어서 참고 해봤다. 주소는 아래와 같다. . https://www.kaggle.com/abhinavgargacb/heart-attack-eda-predictor-95-accuracy-score#Exploratory-Data-Analysis- . fig = plt.figure(figsize=(24, 6)) axes = [fig.add_subplot(1,5,i) for i in range(1, 6)] fig.patch.set_facecolor(&#39;#eaeaf2&#39;) for i in range(5): var = continuous[i] ax = axes[i] ax.grid(axis=&#39;y&#39;, linestyle=&#39;:&#39;) ax.text(0.5, 1.05, var.title(), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;, fontsize=14, fontweight=&#39;bold&#39;, transform=ax.transAxes) color = sns.color_palette(&#39;deep&#39;)[i] sns.violinplot(data=df, y=var, ax=ax, color=color) ax.set_xlabel(&#39;&#39;) ax.set_ylabel(&#39;&#39;) . . age : 표본이 중장년층을 중심으로 퍼져있다. 아무래도 심장병이라는 질환의 특성상 병원까지 와서 표본으로 수집되는 어린 환자는 적고, 고령층의 경우 인구수가 적어서 그런 것으로 생각된다. | trtbps : 일정 범위 내에서 정규분포와 같은 모습을 보이나 오른쪽 꼬리가 꽤 길게 늘어져 있다. | chol : 콜레스테롤은 대표적인 심장병의 원인 중 하나로 꼽힌다. 콜레스테롤이 아주 높은 outlier가 보인다. | thalachh : 왼쪽 꼬리가 꽤나 두꺼운 분포이다. (최대 심박수가 60인 사람은 평소 심박수가 몇일지 궁금해진다) | oldpeak : 오른쪽 꼬리가 아주 두껍고 멀리 떨어진 outlier가 보인다. | . fig = plt.figure(figsize=(24, 10)) axes = [fig.add_subplot(2,4,i) for i in range(1, 9)] fig.patch.set_facecolor(&#39;#eaeaf2&#39;) for i in range(8): var = categorical[i] ax = axes[i] ax.text(0.5, 1.05, var.title(), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;, fontsize=14, fontweight=&#39;bold&#39;, transform=ax.transAxes) sns.countplot(data=df, x=var, ax=ax) ax.set_xlabel(&#39;&#39;) ax.set_ylabel(&#39;&#39;) . . 모든 특성에서 범주간의 불균형이 보인다. | 특히 restecg, slp, caa, thall 에서 아주 심하고 fbs와 cp 에서도 큰 불균형이 발견된다. exng는 다른 특성들에 비해 불균형이 심해보이진 않는다. | . Bivariate Analysis . 여기서부턴 test의 target값이 df에 포함 되었기 때문에 원본 데이터를 보지 못한다.(실전이라면 univariate analysis까지만 데이터를 합하여 볼 수 있을 것이다.) train 데이터로 보도록 하자.(실전처럼!) . fig = plt.figure(figsize=(24, 10)) axes = [fig.add_subplot(2,4,i) for i in range(1, 9)] fig.patch.set_facecolor(&#39;#eaeaf2&#39;) for i in range(8): var = categorical[i] ax = axes[i] ax.text(0.5, 1.05, var.title(), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;, fontsize=14, fontweight=&#39;bold&#39;, transform=ax.transAxes) colorIndex = (2*(i)) % 10 color1 = sns.color_palette(&#39;deep&#39;)[colorIndex] color2 = sns.color_palette(&#39;deep&#39;)[colorIndex + 1] sns.countplot(data=train, x=var, ax=ax, hue=&#39;output&#39;, palette=[color1, color2]) ax.set_xlabel(&#39;&#39;) ax.set_ylabel(&#39;&#39;) . . 1이 조금 더 많은 것은 train.output의 1이 0보다 조금 더 많았던 것 때문이라 생각할 수 있겠지만 조금 더 많은 정도가 아니거나 거꾸로 0이 많은 경우가 있다면 꽤나 유의미한 특성이라 볼 수 있을 것이다. . cp, slp, caa, thall, sex, exng 특성을 보면 특정 범주에 따라 1과 0의 비율이 역전 되는 모습이 많이 보인다. | restecg, fbs의 경우엔 그다지 유의미한 변화가 없다. | . Cramer&#39;s V . 그래프를 가져온 문서에서 거의 그대로 가져왔다. Cramer&#39;s V는 두 이산형 변수의 연관성 척도로 쓰인다. 특히 비교대상 범주가 3개 이상일 때 쓰인다. . Pearson 카이제곱 통계량을 기반으로 만들어진 테스트이다.(계산적인 부분이 궁금하다면 여기를 클릭하자) . def cramers_corrected_stat(x, y): result = -1 conf_matrix = pd.crosstab(x, y) if conf_matrix.shape[0] == 2: correct = False else: correct = True chi2, p = ss.chi2_contingency(conf_matrix, correction=correct)[0:2] n = sum(conf_matrix.sum()) phi2 = chi2/n r, k = conf_matrix.shape phi2corr = max(0, phi2 - ((k-1)*(r-1))/(n-1)) rcorr = r - ((r-1)**2)/(n-1) kcorr = k - ((k-1)**2)/(n-1) result = np.sqrt(phi2corr / min((kcorr-1), (rcorr-1))) return round(result, 6), round(p, 6) for var in categorical: x = train[var] y = train[&#39;output&#39;] cramersV, p = cramers_corrected_stat(x, y) print(f&#39;For variable {var}, Cramer &#39;s V: {cramersV} and p value: {p}&#39;) . . For variable cp, Cramer&#39;s V: 0.463569 and p value: 0.0 For variable restecg, Cramer&#39;s V: 0.110035 and p value: 0.08517 For variable slp, Cramer&#39;s V: 0.36724 and p value: 0.0 For variable caa, Cramer&#39;s V: 0.487659 and p value: 0.0 For variable thall, Cramer&#39;s V: 0.504115 and p value: 0.0 For variable sex, Cramer&#39;s V: 0.297875 and p value: 2e-06 For variable fbs, Cramer&#39;s V: 0.0 and p value: 0.988529 For variable exng, Cramer&#39;s V: 0.439424 and p value: 0.0 . fbs는 연관성이 없어보이고 restecg는 유의수준 $ alpha = 0.05$에서 아쉽게 기각이 되지 않는다. | 위의 두 변수를 제외한 모든 변수에서 귀무가설이 기각되었다. | . fig = plt.figure(figsize=(24, 6)) axes = [fig.add_subplot(1,5,i) for i in range(1, 6)] fig.patch.set_facecolor(&#39;#eaeaf2&#39;) for i in range(5): var = continuous[i] ax = axes[i] ax.grid(axis=&#39;y&#39;, linestyle=&#39;:&#39;) ax.text(0.5, 1.05, var.title(), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;, fontsize=14, fontweight=&#39;bold&#39;, transform=ax.transAxes) colorIndex = (2*(i)) % 10 color1 = sns.color_palette(&#39;deep&#39;)[colorIndex] color2 = sns.color_palette(&#39;deep&#39;)[colorIndex + 1] sns.violinplot(data=train, y=var, x=&#39;output&#39;, ax=ax, palette=[color1, color2]) ax.set_xlabel(&#39;&#39;) ax.set_ylabel(&#39;&#39;) . . 수집된 표본에선 의외로 환자의 연령대가 다양하다. | trtbps, chol, oldpeak 에선 output에 따라 outlier가 다르게 관측된다. | . fig = plt.figure(figsize=(24, 6)) axes = [fig.add_subplot(1,5,i) for i in range(1, 6)] fig.patch.set_facecolor(&#39;#eaeaf2&#39;) for i in range(5): var = continuous[i] ax = axes[i] ax.grid(axis=&#39;y&#39;, linestyle=&#39;:&#39;) ax.text(0.5, 1.05, var.title(), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;, fontsize=14, fontweight=&#39;bold&#39;, transform=ax.transAxes) colorIndex = (2*(i - 1)) % 10 color1 = sns.color_palette(&#39;deep&#39;)[colorIndex] color2 = sns.color_palette(&#39;deep&#39;)[colorIndex + 1] sns.kdeplot(data=train, x=var, hue=&#39;output&#39;, ax=ax, fill=True, palette=[color1, color2]) ax.set_xlabel(&#39;&#39;) ax.set_ylabel(&#39;&#39;) . . age, thalachh, oldpeak 에서 큰 영향이 있는 것으로 보인다. | trtbps, chol 은 그다지 큰 영향이 있는 것으로 보이진 않는다. | . Kruskal-Wallis H-test . 분포 모형이 통계적으로 유의하게 차이가 있는지 확인해보자. 모든 분포가 정규성을 갖지는 않기에 평균보다는 중위수에 대한 검정을 하자. . for var in continuous: gp = train[[var, &#39;output&#39;]].groupby([&#39;output&#39;]) gp_array = [group[var].to_numpy() for name, group in gp] kstat, p = ss.kruskal(*gp_array) kstat, p = round(kstat, 6), round(p, 6) print(f&#39;For variable {var}, Kruskal-Wallis H-test: {kstat} and p value: {p}&#39;) . . For variable age, Kruskal-Wallis H-test: 14.700765 and p value: 0.000126 For variable trtbps, Kruskal-Wallis H-test: 1.288149 and p value: 0.256389 For variable chol, Kruskal-Wallis H-test: 2.346947 and p value: 0.125529 For variable thalachh, Kruskal-Wallis H-test: 36.863825 and p value: 0.0 For variable oldpeak, Kruskal-Wallis H-test: 42.479336 and p value: 0.0 . Point Biserial test . 다른 검정을 하고싶다면 피어슨 상관계수와 값이 동일하긴 하지만 Point Biserial test를 해보자 . for var in continuous: pbistat, p = ss.pointbiserialr(train[var], train[&#39;output&#39;]) pbistat, p = round(pbistat, 6), round(p, 6) print(f&#39;For variable {var}, Point Biserial : {pbistat} and p value: {p}&#39;) . . For variable age, Point Biserial : -0.233782 and p value: 0.000244 For variable trtbps, Point Biserial : -0.104257 and p value: 0.10569 For variable chol, Point Biserial : -0.057714 and p value: 0.371366 For variable thalachh, Point Biserial : 0.393415 and p value: 0.0 For variable oldpeak, Point Biserial : -0.447305 and p value: 0.0 . 두 검정 모두 동일하게 귀무가설을 채택&amp;기각 하였다. 두 결과에서 trtbps, chol 모두 생각보다 작은 값을 보인다. | . Correlation of continuous variables(pearson) . fig = plt.figure(figsize=(12, 8)) fig.patch.set_facecolor(&#39;#eaeaf2&#39;) corr_matrix = train[continuous].corr() mask = np.triu(np.ones_like(corr_matrix)) sns.heatmap(corr_matrix, cmap=&#39;Reds&#39;, annot=True, mask=mask) plt.show() . . 크기가 커봐야 0.4 정도이다. 그다지 높은 선형 상관을 띠는 특성 쌍은 없다. | . Correlation of categorical variables(Cramer&#39;s V) . fig = plt.figure(figsize=(12, 8)) fig.patch.set_facecolor(&#39;#eaeaf2&#39;) corr_matrix = train[categorical].corr(method=lambda x, y: cramers_corrected_stat(x, y)[0]) mask = np.triu(np.ones_like(corr_matrix)) sns.heatmap(corr_matrix, cmap=&#39;Reds&#39;, annot=True, mask=mask) plt.show() . . 커봐야 0.43정도이다. 강한 상관을 보이는 특성쌍은 없는 것으로 보인다. | . EDA Conclusion . Continuous . outlier가 많이 관측되었다. 모델 적합시 영향을 많이 줄 것으로 보인다. . | 스케일을 맞출 필요가 있다. . | oldpeak의 경우 분포가 오른쪽 꼬리를 길게 달고 있다. 하지만 변수에 대한 정확한 설명이 없어 변환이 어려울듯 하다. . | p-value가 생각보다 작아 trtbps, chol이 output 값과 아예 연관이 없다고 보기는 어려울 수 있다. . | 특성들 간의 선형 상관관계는 없는 것으로 보인다. . | . Categorical . 모든 특성에서 범주 간의 심한 불균형이 관측된다. . | fbs의 경우 심한 불균형이 있고 output과 연관이 거의 없는 것으로 검정 되었으므로 제거할 필요가 있어보인다. . | 특성들 간의 상관관계는 없는 것으로 보인다. . | . Model comparison . # Preprocessing from sklearn.metrics import accuracy_score, f1_score, recall_score, precision_score, confusion_matrix, make_scorer from sklearn.metrics import mean_squared_error,r2_score from sklearn.preprocessing import RobustScaler, MinMaxScaler, StandardScaler # Basic Model from sklearn.svm import SVC from sklearn.linear_model import LogisticRegression from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import cross_validate # Boosting Model from sklearn.ensemble import GradientBoostingClassifier, AdaBoostClassifier from xgboost import XGBClassifier # Neural Network Model from sklearn.neural_network import MLPClassifier . . X_train = train_full.drop([&#39;fbs_0&#39;, &#39;fbs_1&#39;, &#39;output&#39;], axis=1) y_train = train_full[&#39;output&#39;] X_test = test_full.drop([&#39;fbs_0&#39;, &#39;fbs_1&#39;, &#39;output&#39;], axis=1) y_test = test_full[&#39;output&#39;] scaler = StandardScaler() scaler.fit(X_train[continuous]) X_train[continuous] = scaler.transform(X_train[continuous]) X_test[continuous] = scaler.transform(X_test[continuous]) # one-hot encoding is already done . models = { &#39;SVM&#39;: SVC(), &#39;Random Forest&#39;: RandomForestClassifier(), &#39;Logistic Regression&#39;: LogisticRegression(), &#39;Gradient Boosting&#39;: GradientBoostingClassifier(), &#39;AdaBoost Classifier&#39;: AdaBoostClassifier(), &#39;XGBoost Classifier&#39; : XGBClassifier(), &#39;MultiLayer Perceptron Classifier&#39; : MLPClassifier() } scoring = {&#39;Accuracy&#39;: make_scorer(accuracy_score), &#39;F1_score&#39;: make_scorer(f1_score), &#39;Recall&#39; : make_scorer(recall_score), &#39;Precision&#39; : make_scorer(precision_score)} . scores = pd.DataFrame({}) for name, model in models.items(): score = cross_validate(model, X_train, y_train, scoring=scoring) temp = pd.DataFrame(score).mean() scores[name] = temp scores = scores.T.drop(&#39;score_time&#39;, axis=1) scores . fit_time test_Accuracy test_F1_score test_Recall test_Precision . SVM 0.005021 | 0.826020 | 0.842251 | 0.856125 | 0.832761 | . Random Forest 0.150434 | 0.805782 | 0.819559 | 0.811681 | 0.832945 | . Logistic Regression 0.008422 | 0.834439 | 0.851540 | 0.871795 | 0.835409 | . Gradient Boosting 0.091337 | 0.818027 | 0.836435 | 0.849288 | 0.826028 | . AdaBoost Classifier 0.076684 | 0.768367 | 0.795258 | 0.819088 | 0.775694 | . XGBoost Classifier 0.058072 | 0.801531 | 0.821968 | 0.834473 | 0.810124 | . MultiLayer Perceptron Classifier 0.260454 | 0.834779 | 0.848088 | 0.841880 | 0.857307 | . fig = plt.figure(figsize=(15, 4)) fig.add_subplot(121) fig.patch.set_facecolor(&#39;#eaeaf2&#39;) sns.set_style(&#39;whitegrid&#39;) plt.title(&#39;Models CV Accuracy&#39;) sns.barplot(scores.test_Accuracy, scores.index, alpha=0.85) plt.xlim((0.75, 0.86)) fig.add_subplot(122) plt.title(&#39;Models CV F1-score&#39;) sns.barplot(scores.test_F1_score, scores.index, alpha=0.9) plt.yticks([]) plt.xlim((0.75, 0.86)) plt.tight_layout() plt.show() . . Logistic Regression 모델이 Accuracy Score, F1 Score 모두 가장 높다. | . GridSearchCV . from sklearn.model_selection import GridSearchCV model = LogisticRegression(penalty=&#39;elasticnet&#39;, solver=&#39;saga&#39;, max_iter=500, random_state=42) params = {&#39;C&#39; : np.arange(0.1, 1, 0.1), &#39;l1_ratio&#39; : np.arange(0, 1, 0.05)} gs = GridSearchCV(estimator=model, param_grid=params, scoring=make_scorer(accuracy_score), cv=5, n_jobs=-1) gs.fit(X_train, y_train) . . GridSearchCV(cv=5, error_score=nan, estimator=LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, l1_ratio=None, max_iter=500, multi_class=&#39;auto&#39;, n_jobs=None, penalty=&#39;elasticnet&#39;, random_state=42, solver=&#39;saga&#39;, tol=0.0001, verbose=0, warm_start=False), iid=&#39;deprecated&#39;, n_jobs=-1, param_grid={&#39;C&#39;: array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]), &#39;l1_ratio&#39;: array([0. , 0.05, 0.1 , 0.15, 0.2 , 0.25, 0.3 , 0.35, 0.4 , 0.45, 0.5 , 0.55, 0.6 , 0.65, 0.7 , 0.75, 0.8 , 0.85, 0.9 , 0.95])}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=False, scoring=make_scorer(accuracy_score), verbose=0) . print(gs.best_params_) . {&#39;C&#39;: 0.30000000000000004, &#39;l1_ratio&#39;: 0.1} . 혹시나 해서 elasticnet penalty를 적용해봤지만 l2 만으로도 충분해보인다. . model= LogisticRegression(penalty=&#39;elasticnet&#39;, solver=&#39;saga&#39;, max_iter=500, C=0.3, l1_ratio=0.1, random_state=42) model.fit(X_train, y_train) y_pred = model.predict(X_test) cm = confusion_matrix(y_test, y_pred) df_cm = pd.DataFrame(cm) sns.heatmap(df_cm, annot=True, cmap=&#39;Reds&#39;) plt.title(&#39;Confusion Matrix for Logistic&#39;, fontsize=15) plt.xlabel(&quot;Predicted&quot;) plt.ylabel(&quot;True&quot;) plt.show() print(&#39;Accuracy : &#39;,accuracy_score(y_test, y_pred)) print(&#39;F1-score : &#39;,f1_score(y_test, y_pred)) . . Accuracy : 0.8852459016393442 F1-score : 0.8888888888888888 . 점수가 기대한 것 보다 잘 나오지 않았다.혹시 데이터셋이 얼마나 잘 나눠졌느냐에 따라 모델의 점수가 달라지지 않을까? 라는 의심이 든다. 데이터 셋의 크기가 작기 때문에 random_state에 따라 점수가 크게 달라질 수도 있겠다. 우선 random_state = 65로 나눠진 데이터 셋에 대해 실험해보자. . | . &#49892;&#54744; . random_state=65 &#47196; &#49892;&#54744; . # random_state=65 dataset prep X = df[[&#39;sex&#39;, &#39;restecg&#39;, &#39;cp&#39;, &#39;exng&#39;, &#39;thall&#39;, &#39;caa&#39;, &#39;slp&#39;, &#39;age&#39;, &#39;trtbps&#39;, &#39;chol&#39;, &#39;thalachh&#39;, &#39;oldpeak&#39;]] y = df[&#39;output&#39;] # models &amp; scoring models = { &#39;SVM&#39;: SVC(), &#39;Random Forest&#39;: RandomForestClassifier(), &#39;Logistic Regression&#39;: LogisticRegression(), &#39;Gradient Boosting&#39;: GradientBoostingClassifier(), &#39;AdaBoost Classifier&#39;: AdaBoostClassifier(), &#39;XGBoost Classifier&#39; : XGBClassifier(), &#39;MultiLayer Perceptron Classifier&#39; : MLPClassifier() } scoring = {&#39;Accuracy&#39;: make_scorer(accuracy_score), &#39;F1_score&#39;: make_scorer(f1_score), &#39;Recall&#39; : make_scorer(recall_score), &#39;Precision&#39; : make_scorer(precision_score)} . . encode_columns = categorical.copy() encode_columns.remove(&#39;fbs&#39;) X = pd.get_dummies(X, columns=encode_columns) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=65) #this scaler = StandardScaler() scaler.fit(X_train[continuous]) X_train[continuous] = scaler.transform(X_train[continuous]) X_test[continuous] = scaler.transform(X_test[continuous]) . scores = pd.DataFrame({}) for name, model in models.items(): score = cross_validate(model, X_train, y_train, scoring=scoring) temp = pd.DataFrame(score).mean() scores[name] = temp scores = scores.T.drop(&#39;score_time&#39;, axis=1) scores . . fit_time test_Accuracy test_F1_score test_Recall test_Precision . SVM 0.004664 | 0.810034 | 0.829819 | 0.856410 | 0.806929 | . Random Forest 0.150327 | 0.789456 | 0.811416 | 0.833903 | 0.792085 | . Logistic Regression 0.010863 | 0.834864 | 0.853075 | 0.886610 | 0.825573 | . Gradient Boosting 0.088992 | 0.743793 | 0.776820 | 0.818519 | 0.741690 | . AdaBoost Classifier 0.076208 | 0.747874 | 0.772512 | 0.788319 | 0.763996 | . XGBoost Classifier 0.034040 | 0.776956 | 0.805907 | 0.856695 | 0.763046 | . MultiLayer Perceptron Classifier 0.293770 | 0.809949 | 0.830393 | 0.856125 | 0.807823 | . CV라서 그런지 생각보다 드라마틱한 변화는 없다. 오히려 내려간 느낌이다. 데이터 셋이 작기 때문에 당연한 것이라 생각된다. . from sklearn.model_selection import GridSearchCV model = LogisticRegression(penalty=&#39;elasticnet&#39;, solver=&#39;saga&#39;, max_iter=500, random_state=42) params = {&#39;C&#39; : np.arange(0.1, 1, 0.1), &#39;l1_ratio&#39; : np.arange(0, 1, 0.05)} gs = GridSearchCV(estimator=model, param_grid=params, scoring=make_scorer(accuracy_score), cv=5, n_jobs=-1) gs.fit(X_train, y_train) . . GridSearchCV(cv=5, error_score=nan, estimator=LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, l1_ratio=None, max_iter=500, multi_class=&#39;auto&#39;, n_jobs=None, penalty=&#39;elasticnet&#39;, random_state=42, solver=&#39;saga&#39;, tol=0.0001, verbose=0, warm_start=False), iid=&#39;deprecated&#39;, n_jobs=-1, param_grid={&#39;C&#39;: array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]), &#39;l1_ratio&#39;: array([0. , 0.05, 0.1 , 0.15, 0.2 , 0.25, 0.3 , 0.35, 0.4 , 0.45, 0.5 , 0.55, 0.6 , 0.65, 0.7 , 0.75, 0.8 , 0.85, 0.9 , 0.95])}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=False, scoring=make_scorer(accuracy_score), verbose=0) . print(gs.best_params_) . . {&#39;C&#39;: 0.1, &#39;l1_ratio&#39;: 0.0} . model= LogisticRegression(penalty=&#39;l2&#39;, max_iter=500, C=0.1, random_state=42) model.fit(X_train, y_train) y_pred = model.predict(X_test) cm = confusion_matrix(y_test, y_pred) df_cm = pd.DataFrame(cm) sns.heatmap(df_cm, annot=True, cmap=&#39;Reds&#39;) plt.title(&#39;Confusion Matrix for Logistic&#39;, fontsize=15) plt.xlabel(&quot;Predicted&quot;) plt.ylabel(&quot;True&quot;) plt.show() print(&#39;Accuracy : &#39;,accuracy_score(y_test, y_pred)) print(&#39;F1-score : &#39;,f1_score(y_test, y_pred)) . . Accuracy : 0.9672131147540983 F1-score : 0.967741935483871 . random_state=65 에선 점수가 무려 96.72%로 나온다. 혹시 더 잘 나눠주는 random_state는 없을까? . random_state = 0 ~ 999 . Accuarcy_list = [] F1_list = [] for i in range(1000): X = df[[&#39;sex&#39;, &#39;restecg&#39;, &#39;cp&#39;, &#39;exng&#39;, &#39;thall&#39;, &#39;caa&#39;, &#39;slp&#39;, &#39;age&#39;, &#39;trtbps&#39;, &#39;chol&#39;, &#39;thalachh&#39;, &#39;oldpeak&#39;]] y = df[&#39;output&#39;] encode_columns = categorical.copy() encode_columns.remove(&#39;fbs&#39;) X = pd.get_dummies(X, columns=encode_columns) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=i) scaler = StandardScaler() scaler.fit(X_train[continuous]) X_train[continuous] = scaler.transform(X_train[continuous]) X_test[continuous] = scaler.transform(X_test[continuous]) model = LogisticRegression(penalty=&#39;l2&#39;, max_iter=500) params = {&#39;C&#39; : np.arange(0.1, 1, 0.1),} gs = GridSearchCV(estimator=model, param_grid=params, scoring=make_scorer(accuracy_score), cv=5, n_jobs=-1) gs.fit(X_train, y_train) C = gs.best_params_[&#39;C&#39;] model= LogisticRegression(penalty=&#39;l2&#39;, max_iter=500, C=C) model.fit(X_train, y_train) y_pred = model.predict(X_test) acc = accuracy_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) Accuarcy_list.append(acc) F1_list.append(f1) . . plt.bar(range(100),Accuarcy_list[0:100]) plt.ylim((0.78, 1)) . (0.78, 1.0) . max(Accuarcy_list) . 0.9672131147540983 . random_state = 0 ~ 99 까지의 그래프만 그려보아도 65번이 가장 높아보이는 것을 알 수 있다. random_state=65 에서의 Accuracy가 96.72% 였으니 0~999에서도 random_state=65 에서의 점수가 가장 잘 나오는 것이라 결론지을 수 있겠다. . &#45712;&#45184;&#51216; . 데이터셋이 작은만큼 어떻게 데이터가 나눠졌는가에 따라 점수가 크게 갈린다. . 오히려 모델을 잘 선정하고 튜닝하는 것보다 데이터 셋이 잘 나눠졌을 때 점수 상승 폭이 더욱 컸다. 아무래도 이번 분석은 모델, 튜닝, 이런 것들 보다도 데이터셋의 크기의 중요성과 잘 나눠진 데이터셋이란 무엇인지에 대해 생각할 수 있던 기회였다. . &#48152;&#49457;&#47928; . 의료데이터의 데이터 포인트 하나하나는 숫자가 아니라 환자다. . 현실의 문제에선 &quot;데이터셋이 잘 정제되어있는가?&quot;, &quot;오류가 있는가?&quot;에 대한 문제보다도 먼저 고민해야할 점은 &quot;과연 데이터셋이 존재하는가? 없다면 수집 비용은 얼마인가?&quot;이다. 모델의 비교와 튜닝은 당연히 데이터셋이 존재하고 정제가 된 다음의 문제이다. 의료데이터와 같이 데이터 수집 비용이 큰 데이터의 경우 데이터의 크기가 작은 것이 당연했고 outlier가 있는 이상 데이터 분할을 섬세하게 했어야 했다. EDA 후에 outlier와 범주 불균형의 존재를 확인하고 어떻게 나눌지를 다시 고민했어야했다. . 요즘의 나는 분석 문제를 자주 마주하다보니 데이터의 가치를 종종 잊곤 한다. 그저 풀어야하는 문제로 데이터의 가치가 전락하는 것이다. 빨리빨리 데이터를 통해 모델을 적용해보고 싶은 마음에 그만 분석의 목적을 잊는 것이다. 데이터의 가치를 누구보다도 잘 알아야 할 분석자로썬 아주 아이러니한 상황인 것이다. . 데이터를 분석할 때엔 그것을 나의 문제라고 생각할 때 정말 사소한 부분까지 확인하게 된다. 하지만 최근 데이터를 문제라고 생각하다보니 데이터가 수집 되기까지의 과정을 생각해보지 않았고, 데이터 속 환자를 단순히 숫자로만 인식해버렸다. . 데이터를 분석하기 위해선 당연히 수치화가 필요하다. 객관적인 분석을 위해선 편견을 되도록 배제하는 것 또한 필요하다. 하지만 그 과정속에서 목적을 잃은체 문제 풀이식으로 모델 적용하는 것은 지양해야한다. 데이터 하나하나가 갖는 의미를 잃은체 믹서기에 갈리는 일은 없어야겠다. . 조금 웃기지만 앞으로는 수집된 표본들과 데이터 제공자에게 항상 감사한 마음으로 내 일이다 생각하고 분석을 해야겠다. . 적다보니 느낀점보단 반성문이 되었버렸다.. 잘못했으니 반성하는 것이라 생각하자. .",
            "url": "https://edypidy.github.io/studyblog/kaggle/heart%20desease/jupyter/classification/xgboost/adaboost/lgbm/logistic%20regression/randomforest/mlpclassifier/2021/09/27/kaggle_study-_Heart_Attack_Analysis_&_Prediction_Dataset.html",
            "relUrl": "/kaggle/heart%20desease/jupyter/classification/xgboost/adaboost/lgbm/logistic%20regression/randomforest/mlpclassifier/2021/09/27/kaggle_study-_Heart_Attack_Analysis_&_Prediction_Dataset.html",
            "date": " • Sep 27, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "[ML] SVM, Kernel-SVM with Gaussian-rbf kernel와 기본적인 하이퍼파라미터들",
            "content": ". Intro . SVM 문제는 클래스가 다른 데이터들을 구분하는 초평면을 어떻게 정할 것인가에 대한 문제이다. 일반화 오차에 대한 성능을 높이기 위해 마진을 최대로 하는 초평면을 그린다. iris 데이터에 SVM을 적용해보자. . import numpy as np import pandas as pd from matplotlib.colors import ListedColormap import matplotlib.pyplot as plt def plot_decision_regions(X, y, classifier, test_idx=None, resolution=0.02): # 마커와 컬러맵을 설정합니다. markers = (&#39;s&#39;, &#39;x&#39;, &#39;o&#39;, &#39;^&#39;, &#39;v&#39;) colors = (&#39;red&#39;, &#39;blue&#39;, &#39;lightgreen&#39;, &#39;gray&#39;, &#39;cyan&#39;) cmap = ListedColormap(colors[:len(np.unique(y))]) # 결정 경계를 그립니다. x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) Z = Z.reshape(xx1.shape) plt.contourf(xx1, xx2, Z, alpha=0.3, cmap=cmap) plt.xlim(xx1.min(), xx1.max()) plt.ylim(xx2.min(), xx2.max()) # 샘플의 산점도를 그립니다. for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=colors[idx], marker=markers[idx], label=cl, edgecolor=&#39;black&#39;) # 테스트 샘플을 부각하여 그립니다. if test_idx: X_test, y_test = X[test_idx, :], y[test_idx] plt.scatter(X_test[:, 0], X_test[:, 1], facecolors=&#39;none&#39;, edgecolor=&#39;black&#39;, alpha=1.0, linewidth=1, marker=&#39;o&#39;, s=100, label=&#39;test_set&#39;) . . Data Preparation . from sklearn import datasets iris = datasets.load_iris() input = iris.data[:, [2, 3]] target = iris.target . from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(input, target, test_size=0.3, stratify = target, random_state=1) . 2차원 평면에 시각화를 위해 iris data에서의 petal length와 petal width를 피쳐로 사용하자. . petal(꽃잎)의 길이와 너비로 꽃의 종류를 분류하는 문제가 되겠다.(sepal(꽃받침)보다는 그럴듯한 상관관계가 있을 것으로 예상된다.) . 잘 알려진 데이터니 만큼 전처리 과정이나 EDA는 건너뛰고 바로 피팅 해보자. . test_size=0.3 : train과 test는 7대 3으로 나누었고. stratify=target : target 꽃의 종류의 비율에 맞추어 train과 test를 나누었으며 random_state=1 : 이건 그냥 재현을 위한 시드다. . Fitting with sklearn . from sklearn.preprocessing import StandardScaler ss = StandardScaler() ss.fit(X_train) X_train_std = ss.transform(X_train) X_test_std= ss.transform(X_test) X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) . from sklearn.svm import SVC svm = SVC(kernel=&#39;linear&#39;, C=1.0, random_state=1) svm.fit(X_train_std, y_train) plot_decision_regions(X_combined_std, y_combined, classifier=svm, test_idx=range(105, 150)) # 빈 동그라미가 쳐진 아이들이 test 셋이다. plt.xlabel(&#39;petal length[std]&#39;) plt.ylabel(&#39;petal width[std]&#39;) plt.legend(loc=&#39;upper left&#39;) plt.tight_layout() plt.show() . train set에 피팅된 SVM 모델이 test_set에도 꽤나 잘 들어맞는 모양새다. 딱 두개의 피쳐만 썼는데도 말이다!. . (사실 그냥 데이터가 원래부터 잘 구분되어있긴 했다.) . 그런데 뭔가 조금 이상하다. SVM은 서로 다른 클래스를 구분하는 평면을 만든다고 했는데 어떻게 세개의 클래스는 어떻게 구분 해야하는가? . 이유인 즉슨 디폴트로 &#39;One Versus Rest&#39;가 적용되었기 때문이다. 2번 클래스의 결정 경계와 평면은 (0번 vs 1번, 2번), (1번 vs 0번, 2번)을 거치면서 &#39;0번과 1번의 영역이 정해졌으니 나머지는 2번이겠구나!&#39; 하는 식으로 결정한 셈이다. . Linear hyperlane&#51004;&#47196; &#44396;&#48516;&#46104;&#51648; &#50506;&#45716; &#45936;&#51060;&#53552; . 다 좋고 모델이 클래스를 잘 분류하는 것 같지만 실제 세계의 데이터는 이렇게 이상적이지 못한 경우가 대부분이다. 과연 &#39;직선&#39;, &#39;평면&#39; 과 같은 선형 결정경계만으로 데이터를 잘 나눌 수 있을까? . 아래의 데이터는 그냥 임의로 만들어 본(또 다른 이상적인 것 일지도 모르는) 데이터이다. 1사분면과 3사분면에는 1번이, 2사분면과 4사분면엔 -1번 클래스가 존재하도록 만든 데이터이다.(x, y의 기울기 탄젠트와 클래스가 관련이 있다면 충분히 있을 수 있는 데이터 셋이다) . np.random.seed(1) X_xor = np.random.randn(200, 2) y_xor = np.logical_xor(X_xor[:, 0] &gt; 0, X_xor[:, 1] &lt; 0) y_xor = np.where(y_xor, 1, -1) plt.scatter(X_xor[y_xor == 1, 0], X_xor[y_xor == 1, 1], color=&#39;b&#39;, marker=&#39;^&#39;, label=&#39;1&#39;) plt.scatter(X_xor[y_xor == -1, 0], X_xor[y_xor == -1, 1], color=&#39;r&#39;, marker=&#39;v&#39;, label=&#39;-1&#39;) plt.xlim([-3, 3]) plt.ylim([-3, 3]) plt.hlines(0, -3, 3) plt.vlines(0, -3, 3) plt.legend() plt.tight_layout() plt.show() . 이런 데이터에 Linear SVM Classifier를 적용하면 어떻게 될까? . 당연한 이야기겠지만 선형 초평면으로는 1번 클래스와 -1번 클래스를 절대 나눌 수 없다. . svm = SVC(kernel=&#39;linear&#39;,random_state=1) svm.fit(X_xor, y_xor) plot_decision_regions(X_xor, y_xor, classifier=svm) plt.legend(loc=&#39;upper left&#39;) plt.tight_layout() plt.show() . 그러면 이렇게 해보자. 모든 데이터의 x,y 두 값을 곱해서 z열로 추가하는 것이다. . 투영된 데이터가 3차원 공간상에서 선형 초평면에 의해 분류되길 기대하는 것이다. . X_xor_3d = np.column_stack(( X_xor, X_xor[:, 0] * X_xor[:, 1])) x = np.linspace(-3, 3, 200) y = np.linspace(-3, -3, 200) x, y = np.meshgrid(x, y) fig, ax = plt.subplots(subplot_kw={&quot;projection&quot;: &quot;3d&quot;}) ax.scatter3D(X_xor_3d[y_xor == 1, 0], X_xor_3d[y_xor == 1, 1], X_xor_3d[y_xor == 1, 2], color=&#39;b&#39;, marker=&#39;^&#39;, label=&#39;1&#39;) ax.scatter3D(X_xor_3d[y_xor == -1, 0], X_xor_3d[y_xor == -1, 1], X_xor_3d[y_xor == -1, 2], color=&#39;r&#39;, marker=&#39;v&#39;, label=&#39;-1&#39;) ax.view_init(2,85) ax.set_xlabel(&#39;x&#39;) ax.set_ylabel(&#39;y&#39;) ax.set_zlabel(&#39;z&#39;) plt.legend() plt.tight_layout() plt.show() . 첫번째 열과 두번째 열을 곱하여 3차원 공간에 투영시킨 모습이다. . $z = 0$ 평면으로 두 클래스를 가를 수 있다. . Kenel-SVM&#44284; Kernel&#51032; &#51333;&#47448;&#46308; . 이와 같이 기존의 데이터를 통해 새로운 차원을 추가하여 선형적으로 구분이 되게끔 하는 모델을 Kernel-SVM이라고 한다. . 일반적인 커널 함수는 아래와 같다. . 선형 커널 : &#39;linear&#39; . | 다항 커널 : &#39;poly&#39; . | 가우시안 rbf : &#39;rbf&#39; . | 시그모이드 커널 : &#39;sigmoid&#39; . | . (callable한 객체를 대입할 수도 있다. 자세한 것은 도큐먼트를 참고하자.) . sklearn SVC의 디폴트 커널은 사실 linear가 아니라 가우시안 rbf 커널이다. 여기서는 rbf 커널과 규제 매개변수(하이퍼파라미터)들에 대해 살짝 알아보자. . svm = SVC(kernel=&#39;rbf&#39;, random_state=1, gamma=0.1, C=10, ) svm.fit(X_xor, y_xor) plot_decision_regions(X_xor, y_xor, classifier=svm) plt.legend() plt.tight_layout() plt.show() . Gaussian rbf&#50752; gamma &#47588;&#44060;&#48320;&#49688; . def axes_decision_regions(X, y, classifier, axes, test_idx=None, resolution=0.02): # 마커와 컬러맵을 설정합니다. markers = (&#39;s&#39;, &#39;x&#39;, &#39;o&#39;, &#39;^&#39;, &#39;v&#39;) colors = (&#39;red&#39;, &#39;blue&#39;, &#39;lightgreen&#39;, &#39;gray&#39;, &#39;cyan&#39;) cmap = ListedColormap(colors[:len(np.unique(y))]) # 결정 경계를 그립니다. x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) Z = Z.reshape(xx1.shape) axes.contourf(xx1, xx2, Z, alpha=0.3, cmap=cmap) axes.set_xlim(xx1.min(), xx1.max()) axes.set_ylim(xx2.min(), xx2.max()) # 샘플의 산점도를 그립니다. for idx, cl in enumerate(np.unique(y)): axes.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=colors[idx], marker=markers[idx], label=cl, edgecolor=&#39;black&#39;) # 테스트 샘플을 부각하여 그립니다. if test_idx: X_test, y_test = X[test_idx, :], y[test_idx] axes.scatter(X_test[:, 0], X_test[:, 1], facecolors=&#39;none&#39;, edgecolor=&#39;black&#39;, alpha=1.0, linewidth=1, marker=&#39;o&#39;, s=100, label=&#39;test_set&#39;) gammas = [0.01, 0.1, 0.5, 5] fig, axes = plt.subplots(1,4, figsize=(20,4)) for gamma, ax in zip(gammas, axes): svm = SVC(kernel=&#39;rbf&#39;, random_state=1, gamma=gamma, C=10) svm.fit(X_xor, y_xor) axes_decision_regions(X_xor, y_xor, axes=ax, classifier=svm) ax.set_title(&#39;gamma : {:}&#39;.format(gamma)) axes[0].legend() plt.show() . . gamma가 커질수록 SVM 분류기가 1번 데이터에 과적합 되어가는 모습이다. . 과적합이 되어 가면서 1번 데이터의 결정경계가 동글동글 해지는 것을 볼 수 있는데 이를 가우시안 구라고 부른다. . gamma는 가우시안 구의 크기를 제한하는 매개변수로 이해할 수 있다(커널이 rbf인 것을 기억하자). gamma값을 크게 하면 서포트 벡터(원래 결정경계 근처의 점이라고 여길 수 있다)의 영향 범위가 줄어든다. 샘플에 더욱 적합되고 결정경계는 구불구불해진다. . &#39;rbf&#39; 커널함수(방사 기저함수)는 다음과 같다. . ($ mathbf{x}^{(i)}$는 자료 행렬의 $i$행 즉, $i$번째 데이터이다.) . $$K( mathbf{x}^{(i)}, mathbf{x}^{(j)}) = exp left ( - frac{ left | mathbf{x}^{(i)}- mathbf{x}^{(j)} right |^2}{2 sigma^2} right ) = exp left ( - gamma left | mathbf{x}^{(i)}- mathbf{x}^{(j)} right |^2 right )$$ . 여기서 $ gamma = frac{1}{2 sigma^2}$는 최적화 대상 파라미터가 아닌 하이퍼파라미터이다. . 가우시안 rbf 커널이라 불리는 이유는 가우시안 분포함수와 닮아 있어서 붙은 이름이다. 이름보다 중요한 것은 $ exp$에 있다. 직관적으로 $ exp$ 함수는 매클로린 전개시 다항식의 무한합을 가지니까 무한차원으로의 투영이라 생각할 수 있겠다. 자세한 이론적인 부분은 이 블로그{:target=&quot;_blank&quot;} 이 논문{:target=&quot;_blank&quot;} 을 참고하길 바란다. . iris 데이터에서도 확인해보자. . gammas = [0.1, 1, 5, 50] fig, axes = plt.subplots(1,4, figsize=(20,4)) for gamma, ax in zip(gammas, axes): svm = SVC(kernel=&#39;rbf&#39;, random_state=1, gamma=gamma, C=1) svm.fit(X_train_std, y_train) axes_decision_regions(X_combined_std, y_combined, axes=ax, classifier=svm, test_idx=range(105,150)) ax.set_title(&#39;gamma : {:}, test_score : {:.2f}&#39;.format(gamma, svm.score(X_test_std, y_test))) axes[0].legend() plt.show() . gamma값이 커질수록 2번 타겟을 제외한 나머지 데이터에 과적합 되어가는 것을 볼 수 있다.(One Versus Rest에 의해 n가지의 클래스 레이블이 있으므로 n-1개의 가우시안 구로 적합되어 간다.) . train_scores, test_scores=[], [] gammas = np.arange(0.1, 1000) for gamma in gammas: svm = SVC(kernel=&#39;rbf&#39;, random_state=1, gamma=gamma, C=1).fit(X_train_std, y_train) train_scores.append(svm.score(X_train_std, y_train)); test_scores.append(svm.score(X_test_std, y_test)) differ = [4*np.abs(tr - ts) for tr, ts in zip(train_scores, test_scores)] plt.plot(gammas, train_scores, label=&#39;train&#39;); plt.plot(gammas, test_scores, label=&#39;test&#39;); plt.plot(gammas, differ, label=&#39;differ*4&#39;) plt.vlines(34, 0, 1, linestyle=&#39;--&#39;); plt.text(1, 0.6,&#39;$gamma = 34$&#39;, fontsize=12) plt.title(&#39;Train &amp; Test scores for Gammas&#39;); plt.xlabel(&#39;Gamma&#39;); plt.ylabel(&#39;score&#39;) plt.xscale(&#39;log&#39;); plt.legend(loc=&#39;center left&#39;); plt.grid() plt.show() . 역시 gamma값이 높아질수록 과적합되어가는 모습을 볼 수 있다. . 낮았을 때는 과소적합 되어있는데 gamma값을 키우는 것으로 해결을 볼 수 있겠다. gamma = 34에서 최적인듯 하다.(데이터 수가 적어서 일반화를 하기엔 아직은 검증이 다소 필요해보인다.) . Gaussian rbf&#50752; C&#47588;&#44060;&#48320;&#49688; . 매개변수 C는 sklearn의 여러 모델들에서 과적합 규제 매개변수로써 쓰인다. 보통 $ alpha$의 역수로 생각할 수 있는데 C가 커질수록 과대적합에 대한 규제가 완화된다고 이해할 수 있다.(모델은 과적합될 가능성이 커진다.) . C = [0.01, 1, 10, 100] fig, axes = plt.subplots(1,4, figsize=(20,4)) for c, ax in zip(C, axes): svm = SVC(kernel=&#39;rbf&#39;, random_state=1, gamma=1, C=c) svm.fit(X_train_std, y_train) axes_decision_regions(X_combined_std, y_combined, axes=ax, classifier=svm, test_idx=range(105,150)) ax.set_title(&#39;C : {:}, test_score : {:.2f}&#39;.format(c, svm.score(X_test_std, y_test))) axes[0].legend() plt.show() . C가 커질수록 최적화 해야하는 비용함수에서의 패널티 함수가 커진다. 즉, C는 커질수록 분류 오차에 대한 비용을 키운다. . 주의해야 할 점은 SVM의 패널티 함수는 Ridge나 Lasso와 달리 가중치 벡터 $ mathbf{w}$의 함수가 아니라 상수 C와 분류오차 $ xi^{(i)}$를 곱하여 더한 함수라는 것이다. . 그러므로 C가 커질수록 분류 오차에 대한 비용이 커진다는 것을 모델이 분류오차 $ xi^{(i)}$의 존재에 대해 더욱 민감하게 반응한다고 이해할 수 있다. C값이 크다면 분류오차를 크게 평가하고 배제하려는 쪽으로 과대적합될 것이다.(C값이 작아서 분류오차를 무시한다면 더울 일반화 된 모델이 나올 것이다.) . 따라서 C가 커질수록 훈련 데이터셋에 과대적합이 되어가고 C가 작아질수록 모델이 일반화 된다고 확인할 수 있겠다. . 릿지와 라쏘, 로지스틱 회귀에서 $ alpha$와 C를 통해 규제의 정도를 제어할 수 있었다. SVM에서의 C도 릿지와 라쏘에서늬 $ alpha$와 반비례하고 로지스틱의 C와 동일한 역할을 수행하는 하이퍼파라미터라고 할 수 있다. . &#50836;&#50557; . svm의 SVC에는 기본적인 파라미터 X, y, kernel=&#39;rbf&#39;, gamma=&#39;scale&#39;, C=1,(random_state=None, decision_function_shape=&#39;ovr) 가 있다. 하이퍼파라미터는 kernel, gamma와 C가 있다. . kernel : 커널함수이다. 상위 차원의 매핑함수($ phi$)를 통해 상위 차원에서의 선형 초평면을 구하고 그것을 매핑함수의 역함수($ phi^{-1}$)로 원래 차원으로 가져오는 수고를 줄인 하나의 함수 $K$이다. 머서의 조건만 만족하면 $ phi$를 모르더라도 $K$가 존재하여 커널함수로 사용할 수 있음이 보장된다. 기본값은 rbf(방사 기저 함수 또는 가우시안 커널)이다. | gamma : rbf에서는 gamma가 클수록 가우시안 구의 크기를 제한하는 것으로 이해할 수 있다. 결정경계가 샘플에 가까워지고 구불구불해진다.(클수록 과적합 된다고 이해할 수도 있다.) | C : 분류오차를 얼마나 신경쓸 것인지 조절한다. 클수록 분류오차에 대해 엄격해지고 작을수록 분류오차를 무시한다. 규제 측면에서 릿지와 라쏘에서의 $ alpha$ 와 반비례하고 로지스틱의 C와 동일한 역할을 수행하는 하이퍼파라미터이다. 기본값이 1인 것을 고려하면 SVC는 하드 마진svm이 아닌 소프트 마진 svm이다. 선형 초평면으로 완전히 구분되지 않는 데이터셋에 C=0을 설정하면 에러가 난다. | . &#45908; &#44277;&#48512;&#54644;&#50556; &#54624; &#44163;&#46308; . SVM을 이론적으로 이해하려면 추가로 공부해볼만한 것들을 정리해 보았다. . 최적화 문제 라그랑주 프리멀 함수 | 라그랑주 듀얼 함수 | KKT 조건 | . | SVM 유도(하드 마진) 기본적인 아이디어 | 마진 유도 | 최적화 대상 및 제약 조건 | 라그랑주 프리멀, 듀얼 라그랑주 프리멀 함수 유도 | 프리멀 함수 w, b 편미분 = 0 | 라그랑주 듀얼 함수 유도 | | 듀얼리티 갭 KKT 조건 확인 | | . | SVM 유도(소프트 마진) 분류오차 ξ | 최적화 대상 및 제약 조건 ξ와 C | . | 라그랑주 프리멀, 듀얼 | KKT 조건 확인 | . | 커널 SVM 커널의 필요성 | 프리멀, 듀얼 문제 필요성(핸즈온 223) | 매핑 함수 | 커널 | 커널 SVM 유도 최적화 대상 및 제약 조건 | 라그랑주 프리멀, 듀얼 | KKT 조건 확인 | | 머서의 정리와 조건 | 커널 예시 | . | 추가 온라인 SVM | SVM 회귀 | 쿼드래틱 프로그래밍 | . | .",
            "url": "https://edypidy.github.io/studyblog/jupyter/svm/kernel-svm/classifying/hyper-lane/kernel/gaussian-rbf/2021/08/20/SVM(%EC%B5%9C%EC%A2%85).html",
            "relUrl": "/jupyter/svm/kernel-svm/classifying/hyper-lane/kernel/gaussian-rbf/2021/08/20/SVM(%EC%B5%9C%EC%A2%85).html",
            "date": " • Aug 20, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "[ML]로지스틱 회귀 유도 및 scikit-learn api 맛보기",
            "content": ". Intro . import matplotlib.pyplot as plt import numpy as np fig, ax = plt.subplots(1,3, figsize=(12,4)) # 시그모이드 def sigmoid(z): return 1/(1 + np.exp(-z)) z = np.linspace(-3, 3, 100) ax[0].plot(z, sigmoid(z)) ax[0].text(-2.7,0.78,&#39;$y = 1/(1+e^{-z})$&#39;, fontsize = 13) ax[0].axvline(0.0, color=&#39;red&#39;, linewidth=0.5) ax[0].set_ylim(-0.1, 1.1) ax[0].set_title(&#39;Sigmoid&#39;) ax[0].set_xlabel(&#39;z = wx&#39;) ax[0].set_ylabel(&#39;phi(z)&#39;) ax[0].set_yticks([0, 0.5, 1]) ax[0].yaxis.grid() plt.tight_layout() # 로짓 def logit(p): return np.log(p/(1-p)) p = np.linspace(0.06, 0.94, 100) ax[1].plot(p, logit(p)) ax[1].text(0.08,1.6,&#39;$y = log(p/(1-p))$&#39;, fontsize = 13) ax[1].axhline(0.0, color=&#39;red&#39;, linewidth=0.5) ax[1].set_xlim(-0.1, 1.1) ax[1].set_title(&#39;Logit&#39;) ax[1].set_xlabel(&#39;p&#39;) ax[1].set_ylabel(&#39;logit(p)&#39;) ax[1].set_xticks([0, 0.5, 1]) ax[1].xaxis.grid() plt.tight_layout() # 합성함수 p = np.linspace(0.06, 0.94, 100) ax[2].plot(p, sigmoid(logit(p))) ax[2].text(0.62,0.42,&#39;$y = p$&#39;, fontsize = 15) ax[2].set_xlim(0, 1) ax[2].set_ylim(0, 1) ax[2].set_title(&#39;Sigmoid(Logit)&#39;) ax[2].set_xlabel(&#39;p&#39;) ax[2].set_ylabel(&#39;phi(logit(p))&#39;) ax[2].grid() plt.tight_layout() plt.show() . . 나는 학교 회귀분석 과목에서 로지스틱 함수를 배울때 왜 &#39;오즈&#39; 라는 개념을 굳이 사용할까 라는 의문을 항상 가지면서 공부했다. 교수님께 여쭤보았을 땐 그저 &quot;오즈는 승산이죠~&quot; 라는 답변을 주셨지만 도통 그 의미를 이해할 수 없었다. 어차피 확률과 일대일 대응인 오즈라는 개념을 굳이 왜 쓰는 것인가? 확률이 더 직관적이고 좋은데 말이다. 고민 끝에 내린 답은 선형 회귀에서의 예측되는 확률이 엇나가는 것을 로짓 변환을 통해 미연에 방지할 수 있기 때문이라는 것이다. . 확인을 위해 확률을 단순 선형회귀로 예측하는 것과 로지스틱 회귀로 예측한 것을 비교해보자. . Data preparation . np.random.seed(1) data0_input = 0.3*np.random.randn(30) data1_input = 1 + 0.5*np.random.randn(30) data0_target = np.zeros(30) data1_target = np.ones(30) data0 = np.column_stack((data0_input, data0_target)) data1 = np.column_stack((data1_input, data1_target)) # 데이터 로드 data = np.row_stack((data0, data1)) data = np.random.permutation(data) print(data[:5]) . [[-0.20511836 0. ] [-0.03686707 0. ] [ 0.17484456 0. ] [ 0.44134483 1. ] [ 0.82532864 1. ]] . plt.scatter(data0_input, data0_target, label=&#39;data0&#39;) plt.scatter(data1_input, data1_target, label=&#39;data1&#39;) plt.grid() plt.legend() plt.show() . &#54869;&#47456; &#50696;&#52769;&#49884; Linear Regression&#51032; &#47928;&#51228;&#51216; &#48143; activation function &#52628;&#47200; . input, target = data[:,0].reshape(-1,1), data[:,1].reshape(-1,) # 단순선형회귀 from sklearn.linear_model import LinearRegression lr = LinearRegression() lr.fit(input, target) print(lr.score(input, target)) print(lr.coef_, lr.intercept_) . 0.6788575359335094 [0.64269595] 0.17212798057869722 . x = np.linspace(-0.7, 2.1, 100) plt.plot(x, 0.6427*x + 0.1721, label=&#39;lr&#39;) plt.plot(x, sigmoid(0.6427*x + 0.1721), label=&#39;sigmoid(lr)&#39;) plt.scatter(data0_input, data0_target) plt.scatter(data1_input, data1_target) plt.vlines(-0.1721/0.6427, 0., 0.5, linestyles=&#39;--&#39;) plt.text(-0.5, 0.7, &#39;Does it looks like p=0.5?&#39;) plt.grid() plt.legend() plt.show() . 단순 선형회귀로 확률을 추정해보았으나 확률이 0과 1을 넘어가는 기이한 형상을 띤다. 이는 잘못된 추정이라 볼 수 있다. 시그모이드가 0과 1사이의 값으로 바꿔준다는 말에 혹해서 시그모이드 함수에 단순선형회귀식을 넣어보더라도 전혀 데이터의 분포를 말해주지 못하는 것 같다. . 문제를 해결할 방법으로는 단순선형회귀로 추정값이 로그값이면 된다. 단순선형회귀 추정값의 범위로 실수 전체가 타당해질 수 있다. 그렇다면 $ log(p) = mathbf{w^T x}$ 로 추정한다면 괜찮을까? 아쉽지만 로그확률을 다시 확률로 해석할 때엔 지수함수가 쓰인다(활성화 함수).따라서 $p = e^{ log(p)} = e^{ mathbf{w^T x}}$가 0 근처에선 좋은 확률의 추정치를 줄 수는 있지만 1을 넘어가는 외삽에선 그다지 쓸모가 없을 것이다. . | 활성화 함수의 범위도 중요하다는 것을 위에서 알았다. 이제 추정값과 활성화함수 짝꿍을 위한 조건은 아래와 같다. . 단순선형회귀로 추정하는 대상이 로그값이면서 | 확률로의 활성화함수가 0과 1사이의 값을 가져야한다. | | . 마침 로그오즈가 확률$p$의 함수이면서 동시에 역함수(시그모이드 함수)가 0과 1사이의 값인 것이다. 따라서 아래와 같은 추정이 가능해졌다. . $$inverse of log( frac{p}{1-p})= frac{1}{1+e^{-z}}$$ . $$ log( frac{p}{1-p}) = z = mathbf{w^T x}$$ . $$ frac{1}{1+e^{-z}} = frac{1}{1+e^{- mathbf{w^T x}}} = frac{1}{1+e^{- log(p/1-p)}} = hat{p}$$ . 추정과정만 보면 $ hat{p} = frac{1}{1+e^{- mathbf{w^T x}}}$ 이겠다. . L2&#44144;&#47532; &#48708;&#50857;&#54632;&#49688;&#51032; &#47928;&#51228;&#51216; . x = np.linspace(-0.7, 2.1, 100) plt.plot(x, sigmoid(20*(x-0.5)), label=&#39;rule of thumb sigmoid&#39;) plt.plot(x, sigmoid(0.6427*x + 0.1721), label=&#39;sigmoid(lr)&#39;) # 앞서 선형모형에서 최적화한 계수들을 그저 시그모이드 함수에 넣기만 했기 때문에 시그모이드 자체에 대해서 최적화가 이루어지진 않았음 plt.scatter(data0_input, data0_target) plt.scatter(data1_input, data1_target) plt.grid() plt.legend(loc=&#39;upper left&#39;) plt.show() . 그렇다면 $ mathbf{w^Tx} = log( frac{p}{1-p})$로 생각하여 이를 단순선형회귀로 추정하고 시그모이드 함수에 넣어 확률을 추정하는 셈이 되는 것인가?. . 그건 또 아니다. $ mathbf{w^Tx} = log( frac{p}{1-p})$에서 선형회귀로 추정해버린다면 위의 그래프에서 선형회귀식을 시그모이드 함수에 넣은 것과 같다. . (단순회귀로 추정한 것이 확률이다! 라고 정의한 것에서 사실 로그오즈로 추정한거였다! 로 바뀌었을 뿐이다.) . 결국 이 경우는 회귀직선과 데이터포인트들의 거리비용을 최적화 한 것이지 시그모이드에 회귀직선을 대입한 것과 데이터포인트들과의 거리비용을 최적화한 것이 아니기에 활성화 함수와 포인트들 간에 괴리가 있다. . 그렇다면 아예 비용함수를 $ sum(y^{(i)} - frac{1}{1+e^{- mathbf{w^T x^{(i)}}}})^2$로 정의하면 어떨까? 비용함수를 만들어보자. . $$J( mathbf{w}) = frac{1}{2} sum^{n}_{i=1}( phi( mathbf{w^Tx^{(i)}}) - y^{(i)})^2$$ . $y$들은 0 또는 1의 값을 가지고 비용함수가 L2(유클리디안) 거리비용함수로 정의되어 있으므로 최적화하여 적합되는 시그모이드 함수의 모양은 아래와 같을 것이다. 두 클래스를 구분하는 데에만 초점을 맞춘다면 의미가 없진 않겠지만 확률적 의미를 부여하기엔 너무나 부족해보인다. . x = np.linspace(-0.7, 2.1, 100) plt.plot(x, sigmoid(1000*x - 500)) # 유클리디언 거리가 최소가 되도록 한다면 점에 붙으려 할 것이다. plt.scatter(data0_input, data0_target, label=&#39;data0&#39;) plt.scatter(data1_input, data1_target, label=&#39;data1&#39;) plt.grid() plt.legend() plt.show() . /usr/local/lib/python3.7/dist-packages/ipykernel_launcher.py:8: RuntimeWarning: overflow encountered in exp . Likelihood, Log Likelyhood function&#44284; &#44221;&#49324;&#54616;&#44053;&#48277; . 비용함수를 다르게 정의해야할 필요성을 위에서 보았다. 데이터가 주어져 있으니 여러 데이터포인트들이 그렇게 나올법한 확률을 최대화 시키는 가중치들을 구하면 될 것이다. 가능도함수를 목적함수로 하여 최대화하는 가중치를 찾는 것이 적당해보인다. . 마침 $z^{(i)}$를 로그오즈로 생각하기로 했으니 $ phi(z^{(i)}) = hat{p}^{(i)}$ 즉, 각각을 i번째 데이터포인트의 양성 확률로 생각할 수 있다. 각 데이터포인트들이 서로 독립적이라는 가정하에 가능도함수는 아래와 같다. . $$L( mathbf{w}) = P( mathbf{y} | mathbf{x;w}) = prod^n_{i=1}( phi(z^{(i)}))^{y^{(i)}}(1- phi(z^{(i)}))^{1-y^{(i)}}$$ . 가능도함수를 최대화 하는 것은 로그 가능도함수를 최대화하는 것과 동일하므로 다루기 쉬운 로그 가능도함수를 최대화하자. . $$l( mathbf{w}) = sum^n_{i=1} [ y^{(i)} log phi(z^{(i)}) + (1-y^{(i)}) log (1 - phi(z^{(i)})) ]$$ . 가능도함수에 로그를 적용하면 가능도가 매우 작을 때 0으로 생략되는 것을 미연에 방지한다. 도함수도 쉽게 구할 수 있으니 일석이조다. . 경사하강법 최적화 알고리즘 사용을 위해 로그 가능도함수를 비용함수로 표현하자. . $$J( mathbf{w}) = - sum^n_{i=1} [ y^{(i)} log phi(z^{(i)}) + (1-y^{(i)}) log (1 - phi(z^{(i)})) ]$$ . 비용함수의 이해를 위해 샘플이 하나일 때의 비용을 계산해보자. 해석의 편의를 위해 가중치 대신 가중치마다의 시그모이드와 참값$y$를 변수로 생각하자.(사실 샘플이 하나라서 $ mathbf{w}$ 대신 $ phi(z)$의 함수로 봐도 좋다.) . $$J( phi(z), y; mathbf{w}) = -y log phi(z) - (1-y) log (1 - phi(z))$$ . $y=1$일 때와 $y=0$일 때를 나누어 생각하면 3차원 상의 비용함수 그래프를 2차원에 그릴 수 있다. . $$J( phi(z), y; mathbf{w}) = left { begin{matrix} - log phi(z)&amp; y=1 - log (1 - phi(z))&amp; y=0 end{matrix} right.$$ . def cost_1(z): return - np.log(sigmoid(z)) def cost_0(z): return -np.log(1 - sigmoid(z)) z = np.linspace(-4, 4, 100) phi_z = sigmoid(z) plt.plot(phi_z, cost_1(z), label=&#39;J(w) where y = 1&#39;) plt.plot(phi_z, cost_0(z), linestyle=&#39;--&#39;, label=&#39;J(w) where y = 0&#39;) plt.xlim([0, 1]) plt.ylim([0, 4.1]) plt.xlabel(&#39;$ phi$(z)&#39;) plt.ylabel(&#39;J(w)&#39;) plt.legend(loc = &#39;upper center&#39;) plt.tight_layout() plt.show() . 범주 1에 속하는 샘플이 범주 1에 속할 확률을 높게 예측할수록 그렇게 예측한 가중치의 비용은 0에 가까워졌고 범주 0에 속하는 샘플이 범주 0에 속할 확률을 높게 예측할수록 역시 비용이 0에 가까워졌다. 반대로 잘못된 예측확률에는 큰 비용을 부여한다. . 즉, (맞으면 비용감소, 틀리면 비용증가)이므로 직관과 일치한다. . 클래스 1을 1같다고 하면 비용이 작아지고 . | 클래스 1을 0이라고 하면 비용이 커진다. . | . (클래스 0의 경우 반대) . 알고있는 기존의 경사하강법 규칙으로부터 로지스틱 회귀에서의 경사하강법 규칙이 잘 일반화 되어있는지 확인해보자. . $J( mathbf{w}) = - sum^n_{i=1} [ y^{(i)} log phi(z^{(i)}) + (1-y^{(i)}) log (1 - phi(z^{(i)})) ]$를 $w_j$에 대하여 편미분하면 . $$ frac{ partial J( mathbf{w})}{ partial w_j} = - sum^n_{i=1} [ y^{(i)} frac{1}{ phi(z^{(i)})} + (1-y^{(i)}) frac{1}{(1 - phi(z^{(i)}))} ] frac{ partial phi(z^{(i)})}{ partial w_j}$$ . 한편, $$ frac{ partial phi(z^{(i)})}{ partial w_j} = phi(z^{(i)}) (1 - phi(z^{(i)})) frac{ partial z^{(i)}}{ partial w_j} = phi(z^{(i)}) (1 - phi(z^{(i)}))x^{(i)}_j$$ 이므로 . $$ frac{ partial J( mathbf{w})}{ partial w_j} = - sum^n_{i=1} [ y^{(i)}(1 - phi(z^{(i)})) + (1-y^{(i)}) phi(z^{(i)}) ]x^{(i)}_j = - sum^n_{i=1} [ y^{(i)} - phi(z^{(i)}) ]x^{(i)}_j$$ . 이 된다. . 간단히 나타내면 $$ frac{ partial J( mathbf{w})}{ partial w_j} = - sum (y - phi(z))x_j $$ . | 선형대수적으로 쓰면 아래와 같다. $$ triangledown J_{p times 1} = - mathbf{X_{n times p}^T (y_{p times 1} - phi(X_{n times p}w_{p times 1}))} $$ . | . 다시 돌아와서 로지스틱 비용함수를 최소화하는 가중치를 찾는 것이 목표이므로 경사하강법의 방법을 적용하면 . $$ triangle w_j := - eta frac{ partial J( mathbf{w})}{ partial w_j}$$ . $$w_j = w_j + triangle w_j$$ . $$w_j := w_j + eta sum^n_{i=1} [ y^{(i)} - phi(z^{(i)}) ]x^{(i)}_j$$ . 인데, 이는 로그 가능도함수에 경사상승법을 적용하여 가능도 함수를 최대화 하는 가중치의 업데이트 방법과 동일하다. 즉, 가능도를 최대화하는 가중치와 로지스틱 비용함수를 최소화 하는 가중치는 서로 같다 . $$ mathbf{w := w + triangle w}$$ . $$ triangle mathbf{w} = - eta triangledown J( mathbf{w}) = eta triangledown l( mathbf{w})$$ . &#47196;&#51648;&#49828;&#54001; &#54924;&#44480; &#50508;&#44256;&#47532;&#51608; &#44396;&#54788; &#49892;&#54744; . #collapse-hide class LogisticRegressionGD(object): &quot;&quot;&quot;경사 하강법을 사용한 로지스틱 회귀 분류기 매개변수 eta : float 학습률(0.0 에서 1.0 사이) n_iter : int 훈련 데이터셋 반복횟수 random_state : int 가중치 무작위 초기화를 위한 난수 생성기 시드 속성 w_ : 1d-array 학습된 가중치 cost_ : list 에포크마다 누적된 로지스틱 비용 함수 값 &quot;&quot;&quot; def __init__(self, eta=0.01, n_iter=100, random_state=1): self.eta = eta self.n_iter = n_iter self.random_state = random_state def fit(self, X, y): &quot;&quot;&quot;훈련 데이터 학습 매개변수 -- X : {array-like}, shape = [n_samples, n_features] n_samples개의 샘플과 n_features개의 특성으로 이루어진 훈련데이터 y : array-like, shape = [n_samples] 타깃값 반환값 -- self : object &quot;&quot;&quot; rgen = np.random.RandomState(self.random_state) self.w_ = rgen.normal(loc=0.0, scale=0.01, size=1 + X.shape[1]) self.cost_ = [] for _ in range(self.n_iter): net_input = self.net_input(X) output = self.activation(net_input) errors = (y-output) self.w_[1:] += self.eta * X.T.dot(errors) self.w_[0] += self.eta * errors.sum() # 오차제곱합 대신 로지스틱 비용을 계산합니다. cost = ( -y.dot(np.log(output)) - ((1-y).dot(np.log(1-output))) ) self.cost_.append(cost) return self def net_input(self, X): &quot;&quot;&quot;입력 계산&quot;&quot;&quot; return np.dot(X, self.w_[1:]) + self.w_[0] def activation(self, z): &quot;&quot;&quot;로지스틱 시그모이드 활성화 계산&quot;&quot;&quot; return 1./(1.+ np.exp(-np.clip(z, -250, 250))) def predict(self, X): &quot;&quot;&quot;단위 계단 함수를 사용하여 클래스 레이블을 반환합니다.&quot;&quot;&quot; return np.where(self.net_input(X) &gt;= 0.0, 1, 0) # 최종 입력값이 0보다 크면 시그모이드 값도 0.5보다 크다 # 아래와 동일합니다. # return np.where(self.activation(self.net_input(X)) &gt;= 0.5, 1, 0) . . lgr = LogisticRegressionGD(eta=0.05, n_iter=1000, random_state=1) coef = lgr.fit(input, target).w_ print(coef) . [-7.22145597 15.28156541] . fig, ax = plt.subplots(1, 2, figsize=(15, 4)) epochs = np.arange(0,1000) ax[0].plot(epochs, lgr.cost_) ax[0].set_title(&#39;Does it converges?&#39;) ax[0].set_xlabel(&#39;Epoch&#39;) ax[0].set_ylabel(&#39;Weights&#39;) ax[0].set_xlim((1,1000)) ax[0].set_ylim((3,35)) ax[0].grid() ax[1].plot(epochs, lgr.cost_) ax[1].set_title(&#39;Does it converges?(log scale)&#39;) ax[1].set_xlabel(&#39;Epoch(log scale)&#39;) ax[1].set_xscale(&#39;log&#39;) ax[1].set_xlim((1,1000)) ax[1].set_ylim((3,35)) ax[1].grid() plt.show() . . x = np.linspace(-0.7, 2.1, 100) plt.plot(x, sigmoid(coef[0] + coef[1]*x)) plt.scatter(data0_input, data0_target, label=&#39;data0&#39;) plt.scatter(data1_input, data1_target, label=&#39;data1&#39;) plt.grid() plt.legend() plt.show() . 로지스틱 모델을 Iris-setosa와 Iris-versicolor 붖꽃만 가지고 로지스틱 회귀의 분류모델 구현이 작동하는지 확인해보자. . from sklearn import datasets import numpy as np . iris = datasets.load_iris() print(iris.data[:3]) print(iris.target[:3]) . [[5.1 3.5 1.4 0.2] [4.9 3. 1.4 0.2] [4.7 3.2 1.3 0.2]] [0 0 0] . X = iris.data[:, [2,3]] y = iris.target print(np.unique(y)) . [0 1 2] . from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1, test_size=0.3, stratify=y) . from sklearn.preprocessing import StandardScaler ss = StandardScaler() ss.fit(X_train) X_train_std = ss.transform(X_train) X_test_std = ss.transform(X_test) . X_train_01subset = X_train_std[(y_train == 0) | (y_train == 1)] y_train_01subset = y_train[(y_train == 0) | (y_train == 1)] lgr = LogisticRegressionGD(eta=0.05, n_iter=1000, random_state=1) lgr.fit(X_train_01subset, y_train_01subset) . &lt;__main__.LogisticRegressionGD at 0x7f603fa314d0&gt; . from matplotlib.colors import ListedColormap import matplotlib.pyplot as plt def plot_decision_regions(X, y, classifier, test_idx=None, resolution=0.02): # 마커와 컬러맵을 설정합니다. markers = (&#39;s&#39;, &#39;x&#39;, &#39;o&#39;, &#39;^&#39;, &#39;v&#39;) colors = (&#39;red&#39;, &#39;blue&#39;, &#39;lightgreen&#39;, &#39;gray&#39;, &#39;cyan&#39;) cmap = ListedColormap(colors[:len(np.unique(y))]) # 결정 경계를 그립니다. x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) Z = Z.reshape(xx1.shape) plt.contourf(xx1, xx2, Z, alpha=0.3, cmap=cmap) plt.xlim(xx1.min(), xx1.max()) plt.ylim(xx2.min(), xx2.max()) # 샘플의 산점도를 그립니다. for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=colors[idx], marker=markers[idx], label=cl, edgecolor=&#39;black&#39;) # 테스트 샘플을 부각하여 그립니다. if test_idx: X_test, y_test = X[test_idx, :], y[test_idx] plt.scatter(X_test[:, 0], X_test[:, 1], facecolors=&#39;none&#39;, edgecolor=&#39;black&#39;, alpha=1.0, linewidth=1, marker=&#39;o&#39;, s=100, label=&#39;test_set&#39;) plot_decision_regions(X_train_01subset, y_train_01subset, classifier=lgr) plt.title(&#39;LogisticRegression - GDescent&#39;) plt.xlabel(&#39;petal length[stdzed]&#39;) plt.ylabel(&#39;petal width[stdzed]&#39;) plt.legend(loc=&#39;upper left&#39;) plt.tight_layout() plt.show() . . scikit-learn &#47196;&#51648;&#49828;&#54001; &#54924;&#44480; . 사이킷런 모듈은 로지스틱 회귀 모델을 지원한다. 이 모델은 위의 구현과 달리 세개이상의 다중분류도 지원한다. . from sklearn.linear_model import LogisticRegression lgr = LogisticRegression(C=100.0, random_state=1) lgr.fit(X_train_std, y_train) X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) plot_decision_regions(X_combined_std, y_combined, classifier=lgr, test_idx=range(len(y_train),len(y))) plt.title(&#39;LogisticRegression - GDescent&#39;) plt.xlabel(&#39;petal length[stdzed]&#39;) plt.ylabel(&#39;petal width[stdzed]&#39;) plt.legend(loc=&#39;upper left&#39;) plt.tight_layout() plt.show() . print(lgr.coef_, lgr.intercept_) for i, w0, w1, w2 in zip(range(3), lgr.intercept_, lgr.coef_[:, 0], lgr.coef_[:, 1]): print(&#39;model{:} : {:.2f} + PL * {:.2f} + PW * {:.2f} &#39;.format(i, w0, w1, w2) ) . [[-6.93265988 -5.76495748] [-2.03192177 -0.03413691] [ 8.96458165 5.79909439]] [-0.9576182 5.70388044 -4.74626223] model0 : -0.96 + PL * -6.93 + PW * -5.76 model1 : 5.70 + PL * -2.03 + PW * -0.03 model2 : -4.75 + PL * 8.96 + PW * 5.80 . &#47196;&#51648;&#49828;&#54001; &#54924;&#44480;&#50640;&#49436;&#51032; &#44508;&#51228; . 규제를 사용하여 과대적합을 피하는 것은 이미 다른 문서에서 많이 다루었으므로 살짝만 하고 지나가자(cf-편향과 분산 참고). . 높은 분산은 과대적합에 비례하고(과대적합은 일반화한 모델이 너무 많은 변동을 끌어갔기 때문) 높은 편향은 과소적합에 비례한다(과소적합은 적합이 덜돼서 구조적인 편향이 발생). 과대적합의 경우에는 모델이 가지는 파라미터의 수를 줄이거나 모델이 가지는 모수들의 크기를 제한함으로써(규제) 해결할 수 있다(이 과정을 모델의 복잡도를 줄인다고 표현하기도 한다.). 반대로 과소적합의 경우에는 모델이 가지는 파라미터의 수를 늘려보는 식으로 해결할 수 있겠다. 여기서는 로지스틱 회귀의 규제에 따른 회귀계수의 변화를 보자. . 회귀계수들의 제곱항을 패널티항으로 갖는 L2규제 로지스틱 비용은 다음과 같다. $$J( mathbf{w}) = - sum^n_{i=1} [ y^{(i)} log phi(z^{(i)}) + (1-y^{(i)}) log (1 - phi(z^{(i)})) ] + frac{ alpha}{2} left | left | mathbf{w} right | right |^2$$ . 릿지 회귀과 라쏘 회귀에서 규제항을 제어하는 파라미터는 $ alpha$였지만 사이킷런의 로지스틱 회귀에서 규제항을 제어하는 파라미터는 C이다. 주의할 점은 C는 $ alpha$의 역수이다. C가 클수록 규제는 완화된다. . petal length와 petal width 계수들의 규제 크기에 따른 크기변화를 그래프로 나타내보자. 규제가 완화될수록(C가 커질수록) 회귀계수들의 크기도 커지는 경향이 있는 것을 볼 수 있다. . weights0, weights1, params = [], [], [] for C in np.arange(-5,5): lgr = LogisticRegression(C=10.**C, random_state=1, multi_class=&#39;ovr&#39;) lgr.fit(X_train_std, y_train) weights0.append(lgr.coef_[0]) weights1.append(lgr.coef_[1]) params.append(10.**C) weights0, weights1 = np.absolute(weights0), np.absolute(weights1) plt.plot(params, weights0[:,0], label=&#39;m0:petal length&#39;) plt.plot(params, weights1[:,0], label=&#39;m1:petal length&#39;, linestyle=&#39;--&#39;) plt.plot(params, weights0[:,1], label=&#39;m0:petal width&#39;, linestyle=&#39;-.&#39;) plt.plot(params, weights1[:,1], label=&#39;m1:petal width&#39;, linestyle=&#39;:&#39;) plt.title(&#39;Absolute weights&#39;) plt.xlabel(&#39;C&#39;) plt.ylabel(&#39;Absolute weight&#39;) plt.xscale(&#39;log&#39;) plt.legend() plt.show() . scikit-learn&#51032; &#48708;&#50857;&#54632;&#49688; &#52572;&#51201;&#54868; &#50508;&#44256;&#47532;&#51608; . 로지스틱 비용함수처럼 볼록한 손실함수를 최소화하는 데는 확률적 경사 하강법(SGD) 대신에 더 고급 방법을 사용하는 것이 좋다. 실제 사이킷런은 다양한 최적화 알고리즘을 제공하며 solver= 매개변수로는 아래와 같은 것들이 있다. . &#39;newton-cg&#39; | &#39;lbfgs&#39; | &#39;liblinear&#39; | &#39;sag&#39; | &#39;saga&#39; | . 다중분류 매개변수인 LogisticRegression의 multiclass=의 기본값은 &#39;auto&#39;이다. &#39;auto&#39;로 설정하면 이진 분류이거나 solver=&#39;liblinear&#39;일 경우에 &#39;ovr&#39;(One versus Rest)를 선택하고 그 외에는 &#39;multinomial&#39;을 선택한다. 이는 &#39;liblinear&#39; 최적화 알고리즘이 다항 로지스틱 회귀 손실을 다룰 수 없고 다중클래스 분류를 위해 OvR 방법을 사용해야하기 때문이다. . predict_proba() method&#50752; &#49368;&#54540; &#54616;&#45208; &#50696;&#52769;&#49884; &#51452;&#51032;&#49324;&#54637; . 확률을 예측하고 싶다면 predict_proba 메서드를 사용하여 계산하자. . print(lgr.predict_proba(X_test_std[:3, :])) . [[1.52213484e-12 3.85303417e-04 9.99614697e-01] [9.93560717e-01 6.43928295e-03 1.14112016e-15] [9.98655228e-01 1.34477208e-03 1.76178271e-17]] . print(lgr.predict_proba(X_test_std[:3, :]).argmax(axis=1)) print(lgr.predict(X_test_std[:3, :])) . [2 0 0] [2 0 0] . lgr.predict(X_test_std[0, :].reshape(1,-1)) # lgr.predict(X_test_std[0, :]) 이렇게 하면 에러난다. . array([2]) . print(&#39;단순 인덱싱 뽑기 : &#39;, X_test_std[0, :].shape) print(&#39;2차원 배열로 변환:&#39;, X_test_std[0, :].reshape(1,-1).shape) . 단순 인덱싱 뽑기 : (2,) 2차원 배열로 변환: (1, 2) .",
            "url": "https://edypidy.github.io/studyblog/jupyter/logistic%20regression/classifying/loss%20function/2021/08/18/%EB%A1%9C%EC%A7%80%EC%8A%A4%ED%8B%B1_%ED%9A%8C%EA%B7%80.html",
            "relUrl": "/jupyter/logistic%20regression/classifying/loss%20function/2021/08/18/%EB%A1%9C%EC%A7%80%EC%8A%A4%ED%8B%B1_%ED%9A%8C%EA%B7%80.html",
            "date": " • Aug 18, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "관심사1 . 학습이론, 성공학 | 메타인지 . | 인지심리학 | 행동심리학 . | 테세우스의 배 딜레마 . | 세계사 | 국제 정치 | 경제, 마케팅(플랫폼 마케팅, 라이브 커머스) | 주식, 비트코인 . | 해석학, 선형대수학, 다변수미적분학, 벡터미적분학 | 양자역학 | 다중 우주론, 시뮬레이션 우주론 | . 관심사2 . 인디음악 | 락 | 뮤지컬 | 연극 | 클래식피아노 . | 헬스 | . 좋아하는 것1 . 요리하기 | 허튼 생각하기 | 책읽기 | 글쓰기 | 노래하기 | 산책하기 | 멍때리기 | . 좋아하는 것2 . 효율화 시키기 | 구조화 시키기 | 비틀어서 생각하기 | 당연해 보이는 것에 의문 가지기 | 일반화 시키기 | . 좋아하는 것3 . 비빔냉면, 물냉면, 제육볶음, 마라샹궈 | 육류, 샐러드, 회 | . 좋아하는 것4 . 골든 리트리버, 사모예드, 시바견, 웰시코기, 프렌치 불독, 시고르자브종 | 코리안숏헤어, 스코티쉬폴드, 먼치킨 | 고슴도치, 기니피그 | 오리, 청둥오리 | 거북이, 자라, 도마뱀 | 청개구리, 팩맨 | . 좋아하는 것5 . 프랑크 소세지 두개 + 블랑 맥주 한캔 | 쥬씨 코코넛 망고/천도복숭아 마시면서 산책하기 | 뜨뜻한 목욕탕 가서 누워있다가 시원한 바나나 우유나 웰치스 한 캔 마시면서 집에오기 | 뜨거운 라면에다 시원한 김치 감싸먹기 | 괜찮은 책 하나 사서 책장에 꽂아두기 | .",
          "url": "https://edypidy.github.io/studyblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://edypidy.github.io/studyblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}